// Production Telegram Bot Webhook Handler
import { Handler, HandlerContext, HandlerEvent } from '@netlify/functions';
import { Bot, InputFile, webhookCallback, InlineKeyboard } from 'grammy';

// Constants
const CLAUDE_MODEL = 'claude-3-5-sonnet-20241022';
const IMAGEN_MODEL = 'imagen-4.0-generate-001';
const ANTHROPIC_VERSION = '2023-06-01';

// Gemini Files API Configuration
const FILES_API_THRESHOLD = 15 * 1024 * 1024; // 15MB threshold for Files API
const GEMINI_MODELS = {
  IMAGE_PREVIEW: 'gemini-2.5-flash-image-preview',
  FLASH_EXP: 'gemini-2.0-flash-exp',
  FLASH: 'gemini-1.5-flash'
} as const;

// Import prompt management utilities
import { getImagePrompt, getDobbyImagePrompt, getQAPrompt, getSystemMessage } from '../../src/utils/prompt-manager';

// Import tracking system
import { parseTrackingCommand, handleTrackingCommand, trackMessageMiddleware } from '../../src/utils/tracking-commands';

// Import error handling
import { ensureChatGroupExists, getUserFriendlyErrorMessage, logErrorWithContext } from '../../src/utils/error-handler';
import { TrackingError } from '../../src/types/tracking.types';

// Import version management
import { getVersionInfoForHelp, getFormattedVersionHistory } from '../../src/utils/version-manager';

// Import image editing handlers
import { registerImageEditHandlers } from '../../src/handlers/image-edit-handler';
import { handlePhotoUpload } from '../../src/handlers/photo-upload-handler';

// Import Replicate service
import { replicateService } from '../../src/services/replicate-service';

// Import Supabase
import { supabase } from '../../src/utils/supabase';

// Environment variables - support both Netlify and Render naming
const BOT_TOKEN = process.env.BOT_TOKEN || process.env.TELEGRAM_BOT_TOKEN || '';
const CLAUDE_API_KEY = process.env.CLAUDE_API_KEY || '';
const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY || '';

// =============================================================================
// COST CALCULATION FUNCTIONS
// =============================================================================

/**
 * Calculate cost for Claude API usage
 * Pricing: ~$3 per million input tokens, ~$15 per million output tokens
 */
function calculateClaudeCost(inputTokens: number, outputTokens: number): number {
  const INPUT_COST_PER_MILLION = 3.0;
  const OUTPUT_COST_PER_MILLION = 15.0;

  const inputCost = (inputTokens / 1000000) * INPUT_COST_PER_MILLION;
  const outputCost = (outputTokens / 1000000) * OUTPUT_COST_PER_MILLION;

  return inputCost + outputCost;
}

/**
 * Calculate cost for Google Imagen API usage
 * Pricing: ~$0.020 per image
 */
function calculateImagenCost(): number {
  return 0.020;
}

/**
 * Calculate cost for Gemini Vision API usage
 * Pricing: ~$0.00025 per image analysis
 */
function calculateGeminiVisionCost(): number {
  return 0.00025;
}

/**
 * Calculate cost for Gemini Files API usage
 * Pricing: ~$0.0005 per image upload + processing cost
 */
function calculateGeminiFilesCost(): number {
  return 0.0005;
}

/**
 * Format cost display for users
 */
function formatCost(cost: number): string {
  if (cost < 0.001) {
    return '< $0.001';
  }
  return `$${cost.toFixed(3)}`;
}

// =============================================================================
// GEMINI FILES API INTEGRATION
// =============================================================================

/**
 * Upload image to Gemini Files API for processing large images (>15MB)
 * @param imageBuffer - Buffer containing image data
 * @param mimeType - MIME type of the image (e.g., 'image/jpeg')
 * @returns Promise resolving to file upload response
 */
async function uploadToGeminiFiles(imageBuffer: Buffer, mimeType: string): Promise<{uri: string, name: string}> {
  console.log(`üì§ Uploading image to Gemini Files API (${imageBuffer.length} bytes, ${mimeType})`);

  const startTime = Date.now();

  try {
    // Create multipart form data
    const formData = new FormData();

    // Add metadata
    formData.append('metadata', JSON.stringify({
      file: {
        displayName: `telegram_image_${Date.now()}`
      }
    }));

    // Add the image file
    const blob = new Blob([imageBuffer], { type: mimeType });
    formData.append('file', blob);

    const response = await fetchWithTimeout(
      `https://generativelanguage.googleapis.com/upload/v1beta/files?key=${GOOGLE_API_KEY}`,
      {
        method: 'POST',
        body: formData
      },
      30000 // 30-second timeout for upload
    );

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Files API upload failed: ${response.status} - ${errorText}`);
    }

    const fileData = await response.json();
    const uploadTime = Date.now() - startTime;

    console.log(`‚úÖ File uploaded successfully in ${uploadTime}ms:`, {
      uri: (fileData as any).file?.uri,
      name: (fileData as any).file?.name,
      size: imageBuffer.length
    });

    return {
      uri: (fileData as any).file?.uri,
      name: (fileData as any).file?.name
    };
  } catch (error) {
    console.error('‚ùå Gemini Files API upload error:', error);
    throw error;
  }
}

/**
 * Delete file from Gemini Files API after processing
 * @param fileUri - URI of the file to delete
 */
async function deleteGeminiFile(fileUri: string): Promise<void> {
  try {
    console.log(`üóëÔ∏è Cleaning up Gemini file: ${fileUri}`);

    const response = await fetchWithTimeout(
      `${fileUri}?key=${GOOGLE_API_KEY}`,
      {
        method: 'DELETE'
      },
      10000 // 10-second timeout for deletion
    );

    if (response.ok) {
      console.log(`‚úÖ File deleted successfully: ${fileUri}`);
    } else {
      console.warn(`‚ö†Ô∏è File deletion failed (${response.status}), but continuing...`);
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è File cleanup failed (but continuing):', error);
    // Don't throw - cleanup failure shouldn't stop the main flow
  }
}

/**
 * Process image using Gemini Files API with file URI
 * @param fileUri - URI of the uploaded file
 * @param editRequest - The editing request from user
 * @param modelName - Gemini model to use
 * @returns Promise resolving to API response
 */
async function processImageWithFilesAPI(
  fileUri: string,
  editRequest: string,
  modelName: string
): Promise<Response> {
  console.log(`üîÑ Processing image with Files API using ${modelName}`);

  const requestBody = {
    contents: [{
      parts: [
        {
          text: modelName.includes('2.5-flash-image-preview')
            ? `Generate an edited version of this image with the following modification: ${editRequest}

Important: You must return the edited image itself, not a text description.
Apply the requested changes directly to the image while preserving the original subjects and composition.
Output: Modified image with the requested changes applied.`
            : `You are an image editor. Edit this image based on: "${editRequest}"

Modify the image to fulfill this request while maintaining the original subjects and composition.
Apply the specific changes requested.`
        },
        {
          fileData: {
            mimeType: "image/jpeg",
            fileUri: fileUri
          }
        }
      ]
    }],
    generationConfig: {
      temperature: 0.4,
      maxOutputTokens: 8192
    }
  };

  return await fetchWithTimeout(
    `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${GOOGLE_API_KEY}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody)
    },
    30000 // 30-second timeout
  );
}

// =============================================================================
// ENHANCED FETCH WITH TIMEOUT
// =============================================================================

/**
 * Enhanced fetch with timeout support
 */
async function fetchWithTimeout(
  url: string,
  options: RequestInit,
  timeoutMs: number = 30000
): Promise<Response> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);

  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    if (error instanceof Error && error.name === 'AbortError') {
      throw new Error(`Request timed out after ${timeoutMs}ms`);
    }
    throw error;
  }
}

// Create bot instance with validation
if (!BOT_TOKEN) {
  console.error('‚ùå BOT_TOKEN is not set!');
  console.error('Available env vars:', Object.keys(process.env).filter(k => !k.includes('KEY')));
}

const bot = new Bot(BOT_TOKEN || 'dummy-token-for-build');

// =============================================================================
// CONVERSATION CONTEXT MANAGEMENT
// =============================================================================

// In-memory conversation context for session continuity
interface ConversationMessage {
  role: 'user' | 'assistant';
  content: string;
  timestamp: number;
}

interface ConversationContext {
  messages: ConversationMessage[];
  lastActive: number;
}

const conversationContexts = new Map<string, ConversationContext>();
const CONTEXT_MAX_MESSAGES = 10; // Keep last 10 messages (5 exchanges)
const CONTEXT_TTL = 30 * 60 * 1000; // 30 minutes

// Cleanup old contexts periodically
setInterval(() => {
  const now = Date.now();
  conversationContexts.forEach((context, key) => {
    if (now - context.lastActive > CONTEXT_TTL) {
      conversationContexts.delete(key);
      console.log(`üßπ Cleaned up conversation context for ${key}`);
    }
  });
}, 5 * 60 * 1000); // Check every 5 minutes

/**
 * Get or create conversation context for a user
 */
function getConversationContext(userId: number, chatId: number): ConversationContext {
  const key = `${userId}:${chatId}`;
  let context = conversationContexts.get(key);

  if (!context) {
    context = {
      messages: [],
      lastActive: Date.now()
    };
    conversationContexts.set(key, context);
    console.log(`‚ú® Created new conversation context for user ${userId} in chat ${chatId}`);
  }

  return context;
}

/**
 * Add message to conversation context
 */
function addToContext(userId: number, chatId: number, role: 'user' | 'assistant', content: string): void {
  const context = getConversationContext(userId, chatId);

  context.messages.push({
    role,
    content,
    timestamp: Date.now()
  });

  // Keep only last N messages
  if (context.messages.length > CONTEXT_MAX_MESSAGES) {
    context.messages = context.messages.slice(-CONTEXT_MAX_MESSAGES);
  }

  context.lastActive = Date.now();

  console.log(`üìù Added ${role} message to context. Total messages: ${context.messages.length}`);
}

/**
 * Get conversation history for Claude API
 */
function getContextMessages(userId: number, chatId: number): Array<{role: string, content: string}> {
  const context = getConversationContext(userId, chatId);
  return context.messages.map(msg => ({
    role: msg.role,
    content: msg.content
  }));
}

// =============================================================================
// DUPLICATE MESSAGE PREVENTION
// =============================================================================

// In-memory cache to prevent duplicate message processing
const processedMessages = new Set<string>();
const CACHE_CLEANUP_INTERVAL = 5 * 60 * 1000; // 5 minutes
const MESSAGE_CACHE_TTL = 10 * 60 * 1000; // 10 minutes

// Cleanup old message IDs periodically
setInterval(() => {
  const now = Date.now();
  processedMessages.forEach((messageKey) => {
    const [timestamp] = messageKey.split(':');
    if (now - parseInt(timestamp) > MESSAGE_CACHE_TTL) {
      processedMessages.delete(messageKey);
    }
  });
}, CACHE_CLEANUP_INTERVAL);

// Middleware to prevent duplicate processing
bot.use(async (ctx, next) => {
  const message = ctx.message;
  if (!message) return next();
  
  // Create unique message key: timestamp:chat_id:message_id:user_id
  const messageKey = `${Date.now()}:${ctx.chat.id}:${message.message_id}:${ctx.from?.id}`;
  const checkKey = `${ctx.chat.id}:${message.message_id}:${ctx.from?.id}`;
  
  // Check if we've already processed this message
  const alreadyProcessed = Array.from(processedMessages).some(key => key.includes(checkKey));
  
  if (alreadyProcessed) {
    console.log(`üîÑ Duplicate message detected, skipping: ${checkKey}`);
    return; // Skip duplicate processing
  }
  
  // Mark message as being processed
  processedMessages.add(messageKey);
  console.log(`‚úÖ Processing new message: ${checkKey}`);
  
  return next();
});

// Add tracking middleware to track messages when tracking is active
bot.use(trackMessageMiddleware);

// Error handling middleware
bot.use(async (ctx, next) => {
  try {
    // Ensure chat group exists in database
    await ensureChatGroupExists(ctx);
    await next();
  } catch (error) {
    console.error('Bot middleware error:', error);
    logErrorWithContext(error as Error, {
      chat_id: ctx.chat?.id,
      user_id: ctx.from?.id,
      message_text: ctx.message && 'text' in ctx.message ? ctx.message.text : null

    });
    
    if (error instanceof TrackingError) {
      await ctx.reply(getUserFriendlyErrorMessage(error));
    } else {
      await ctx.reply(`üßô‚Äç‚ôÄÔ∏è **ÎèÑÎπÑÍ∞Ä ÏòàÏÉÅÏπò Î™ªÌïú Î¨∏Ï†úÎ•º ÎßåÎÇ¨ÏäµÎãàÎã§...**

‚ùå ÏùºÏãúÏ†ÅÏù∏ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.

üí° Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî. Î¨∏Ï†úÍ∞Ä ÏßÄÏÜçÎêòÎ©¥ Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Î¨∏ÏùòÌï¥Ï£ºÏÑ∏Ïöî.`);
    }
  }
});

// Helper function to generate image with Imagen
async function generateImageWithImagen(userInput: string, isDobby: boolean = false, userId?: string, chatId?: string) {
  const startTime = Date.now();

  try {
    console.log(`üé® Generating image with Imagen for: "${userInput}"`);

    // Get dynamic prompt from database
    const enhancedPrompt = isDobby
      ? await getDobbyImagePrompt(userInput)
      : await getImagePrompt(userInput);

    console.log(`üìù Using enhanced prompt: "${enhancedPrompt}"`);

    // Use reduced timeout to fit within Netlify's 10-second limit
    // Reduce image size for faster generation
    const response = await fetchWithTimeout(
      'https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict',
      {
        method: 'POST',
        headers: {
          'x-goog-api-key': GOOGLE_API_KEY,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          instances: [{ prompt: enhancedPrompt }],
          parameters: {
            sampleCount: 1,
            sampleImageSize: '1K',  // Imagen 4.0 requires 1K or 2K
            aspectRatio: '1:1'
          }
        })
      },
      20000 // 20-second timeout for Render.com (30-second limit)
    );

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Imagen API error: ${response.status} ${response.statusText} - ${errorText}`);
    }

    const data = await response.json();
    const processingTime = Date.now() - startTime;

    console.log(`üé® Image generation successful in ${processingTime}ms!`);

    // Calculate cost
    const imageCost = calculateImagenCost();

    if ((data as any).predictions && (data as any).predictions.length > 0) {
      const prediction = (data as any).predictions[0];
      if (prediction.bytesBase64Encoded) {
        return {
          imageData: prediction.bytesBase64Encoded,
          mimeType: prediction.mimeType || 'image/png',
          cost: imageCost,
          processingTime
        };
      }
    }

    throw new Error('No image data in response');
  } catch (error) {
    console.error('Imagen API error:', error);
    throw error;
  }
}

// Helper function for Claude API with dynamic prompts and conversation context
async function callClaudeAPI(
  message: string,
  maxTokens: number = 2000,
  temperature: number = 0.7,
  conversationHistory: Array<{role: string, content: string}> = []
) {
  const startTime = Date.now();

  try {
    // Build messages array with conversation history
    const messages: Array<{role: string, content: string}> = [];

    // Add conversation history
    if (conversationHistory.length > 0) {
      messages.push(...conversationHistory);
      console.log(`üí¨ Including ${conversationHistory.length} previous messages for context`);
    }

    // Add current message
    messages.push({
      role: 'user',
      content: message
    });

    // Use enhanced fetch with timeout
    const response = await fetchWithTimeout(
      'https://api.anthropic.com/v1/messages',
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': CLAUDE_API_KEY,
          'anthropic-version': '2023-06-01'
        },
        body: JSON.stringify({
          model: 'claude-3-5-sonnet-20241022',
          max_tokens: maxTokens,
          temperature: temperature,
          messages: messages
        })
      },
      45000 // 45-second timeout for Claude API (increased from 20s due to timeouts)
    );


    const data = await response.json();
    const processingTime = Date.now() - startTime;

    if (response.ok) {
      const responseText = (data as any).content[0]?.text || 'ÏùëÎãµÏù¥ ÏóÜÏäµÎãàÎã§.';

      // Calculate cost based on token usage
      const usage = (data as any).usage;
      const inputTokens = usage?.input_tokens || 0;
      const outputTokens = usage?.output_tokens || 0;
      const cost = calculateClaudeCost(inputTokens, outputTokens);

      return {
        text: responseText,
        cost,
        processingTime,
        inputTokens,
        outputTokens
      };
    } else {
      const errorText = await response.text();
      console.error('Claude API Error Response:', errorText);
      throw new Error((data as any).error?.message || `Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò: ${response.status} ${response.statusText}`);
    }
  } catch (error) {
    console.error('Claude API Error:', error);
    throw error;
  }
}

// Helper function for Claude API (Vision) with retry logic
async function callClaudeVisionAPI(prompt: string, imageData: string, mediaType: string, retries: number = 2) {
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      if (attempt > 0) {
        console.log(`üîÑ Retrying Claude Vision API (attempt ${attempt + 1}/${retries + 1})...`);
        // Wait before retry (exponential backoff)
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }

      console.log(`üñºÔ∏è Calling Claude Vision API for prompt: "${prompt}"`);
      const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': CLAUDE_API_KEY,
        'anthropic-version': ANTHROPIC_VERSION
      },
      body: JSON.stringify({
        model: CLAUDE_MODEL,
        max_tokens: 2000,
        messages: [{
          role: 'user',
          content: [
            {
              type: 'image',
              source: {
                type: 'base64',
                media_type: mediaType,
                data: imageData,
              },
            },
            {
              type: 'text',
              text: prompt
            }
          ]
        }]
      })
    });

      if (response.ok) {
        const data = await response.json();
        console.log('üñºÔ∏è Claude Vision API call successful!');
        return (data as any).content[0]?.text || 'Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.';
      } else {
        // Try to parse error response
        let errorMessage = `Vision API Ïò§Î•ò: ${response.status} ${response.statusText}`;
        let isOverloaded = false;
        try {
          const errorData = await response.json();
          console.error('Claude Vision API Error Response:', errorData);
          errorMessage = (errorData as any).error?.message || errorMessage;
          // Check if it's an overload error
          isOverloaded = (errorData as any).error?.type === 'overloaded_error' ||
                        errorMessage.toLowerCase().includes('overloaded');
        } catch {
          // If JSON parsing fails, use default error message
          console.error('Could not parse error response body');
        }

        // If it's an overload error and we have retries left, throw to retry
        if (isOverloaded && attempt < retries) {
          console.log('üîÑ Claude API is overloaded, will retry...');
          throw new Error(errorMessage);
        } else {
          // Final error, no more retries
          throw new Error(errorMessage);
        }
      }
    } catch (error) {
      console.error(`Claude Vision API Error (attempt ${attempt + 1}):`, error);

      // If this is the last attempt, throw the error
      if (attempt === retries) {
        throw error;
      }
      // Otherwise, continue to next iteration for retry
    }
  }

  // Should not reach here, but just in case
  throw new Error('Claude Vision API failed after all retries');
}

// Centralized error handler
async function handleError(ctx: any, error: Error, command: string, thinkingMessage: any = null) {
  console.error(`Error in ${command}:`, error);

  const errorMessage = `‚ùå **'${command}' ÏûëÏóÖ Ï§ë Ïò§Î•ò Î∞úÏÉù**

**Ïò§Î•ò ÎÇ¥Ïö©:**
${error.message}

üí° Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Î≥¥ÏãúÍ±∞ÎÇò, Î¨∏Ï†úÍ∞Ä Í≥ÑÏÜçÎêòÎ©¥ Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Î¨∏ÏùòÌï¥Ï£ºÏÑ∏Ïöî.`;

  try {
    if (thinkingMessage?.message_id) {
      await ctx.api.editMessageText(
        ctx.chat.id,
        thinkingMessage.message_id,
        errorMessage
      );
    } else {
      await ctx.reply(errorMessage);
    }
  } catch (replyError) {
    console.error('Failed to send error message to user:', replyError);
  }
}

// Helper function to detect questions
function isQuestion(text: string): boolean {
  const questionPatterns = [
    /\?$/,                    // ends with ?
    /^(Î≠ê|Î¨¥Ïóá|Ïñ¥Îñª|Ïñ¥Îîî|Ïñ∏Ï†ú|Ïôú|ÎàÑÍµ¨|Ïñ¥Îäê)/,  // Korean question words
    /^(what|how|where|when|why|who|which)/i,  // English question words
    /(Î∞©Î≤ï|Ïñ¥ÎñªÍ≤å|ÏïåÎ†§Ï§ò|Í∂ÅÍ∏à)/,    // asking for help/info
    /(Ï∂îÏ≤ú|Ï†úÏïà|ÏùòÍ≤¨)/,           // asking for recommendations
  ];

  return questionPatterns.some(pattern => pattern.test(text.trim()));
}

// Helper function to detect Dobby activation
function isDobbyActivated(text: string, isReply: boolean = false): { activated: boolean; command: string | null; content: string } {
  const dobbyPattern = /ÎèÑÎπÑÏïº[,\s]*(.*)/i;
  const match = text.match(dobbyPattern);

  if (!match) {
    return { activated: false, command: null, content: '' };
  }

  const content = match[1].trim();

  // If it's a reply to a photo, default to edit command
  if (isReply) {
    return { activated: true, command: 'edit', content: content };
  }

  // Check for help commands
  if (/(ÏÇ¨Ïö©Î≤ï|ÎèÑÏõÄÎßê|ÏÇ¨Ïö©Î∞©Î≤ï|Î©îÎâ¥Ïñº|Í∞ÄÏù¥Îìú|Î™ÖÎ†πÏñ¥ ÏïåÎ†§|ÎèÑÏõÄ Ï§ò|help)/i.test(content)) {
    return { activated: true, command: 'help', content: content };
  }

  // Check for image generation commands
  if (/(Í∑∏Î†§Ï§ò|Í∑∏Î†§|Í∑∏Î¶º|Ïù¥ÎØ∏ÏßÄ|ÏÉùÏÑ±)/i.test(content)) {
    // Remove only the final command words, not all occurrences
    const imagePrompt = content
      .replace(/\s*(Í∑∏Î¶ºÏùÑ\s+)?Í∑∏Î†§Ï§ò\s*$/i, '')  // Remove "Í∑∏Î¶ºÏùÑ Í∑∏Î†§Ï§ò" at the end
      .replace(/\s*Í∑∏Î†§Ï§ò\s*$/i, '')  // Remove "Í∑∏Î†§Ï§ò" at the end
      .replace(/\s*Í∑∏Î†§\s*$/i, '')  // Remove "Í∑∏Î†§" at the end
      .replace(/\s*ÎßåÎì§Ïñ¥Ï§ò\s*$/i, '')  // Remove "ÎßåÎì§Ïñ¥Ï§ò" at the end
      .replace(/\s*ÏÉùÏÑ±Ìï¥Ï§ò\s*$/i, '')  // Remove "ÏÉùÏÑ±Ìï¥Ï§ò" at the end
      .trim();
    return { activated: true, command: 'image', content: imagePrompt };
  }

  // Check for Q&A commands
  if (/(ÏïåÎ†§Ï§ò|Î≠êÏïº|ÏÑ§Î™ÖÌï¥|Í∞ÄÎ•¥Ï≥ê|Í∂ÅÍ∏à)/i.test(content)) {
    return { activated: true, command: 'ask', content: content };
  }

  // Default to Q&A if no specific command detected
  return { activated: true, command: 'ask', content: content };
}

// Enhanced Q&A function with dynamic prompts and conversation context
async function answerQuestion(question: string, isDobby: boolean = false, userId?: string, chatId?: string) {
  try {
    console.log(`ü§î Processing question: "${question}"`);

    // Get dynamic prompt from database
    const { prompt, maxTokens, temperature } = await getQAPrompt(question, isDobby);

    console.log(`üìù Using ${isDobby ? 'Dobby' : 'standard'} prompt template`);

    // Get conversation context if userId and chatId are provided
    let conversationHistory: Array<{role: string, content: string}> = [];
    if (userId && chatId) {
      const userIdNum = parseInt(userId);
      const chatIdNum = parseInt(chatId);
      conversationHistory = getContextMessages(userIdNum, chatIdNum);

      if (conversationHistory.length > 0) {
        console.log(`üîÑ Continuing conversation with ${conversationHistory.length} previous messages`);
      }
    }

    const claudeResponse = await callClaudeAPI(prompt, maxTokens, temperature, conversationHistory);

    // Store the conversation in context
    if (userId && chatId) {
      const userIdNum = parseInt(userId);
      const chatIdNum = parseInt(chatId);
      addToContext(userIdNum, chatIdNum, 'user', question);
      addToContext(userIdNum, chatIdNum, 'assistant', claudeResponse.text);
    }

    return {
      text: claudeResponse.text,
      cost: claudeResponse.cost,
      processingTime: claudeResponse.processingTime,
      tokenUsage: {
        input: claudeResponse.inputTokens,
        output: claudeResponse.outputTokens
      }
    };
  } catch (error) {
    console.error('Q&A Error:', error);
    throw error;
  }
}

// Helper function to get help message content
async function getHelpMessage(): Promise<string> {
  try {
    const versionInfo = await getVersionInfoForHelp();

    return `üßô‚Äç‚ôÄÔ∏è **ÎèÑÎπÑ AI Î¥áÏûÖÎãàÎã§!** üè†

${versionInfo}

üåü **ÎèÑÎπÑ Í∞úÏù∏ÎπÑÏÑú Î™®Îìú:**
‚Ä¢ üé® **"ÎèÑÎπÑÏïº, ~~~ Í∑∏Î†§Ï§ò"** - ÎßàÎ≤ïÍ∞ôÏùÄ Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±
‚Ä¢ üí¨ **"ÎèÑÎπÑÏïº, ~~~ ÏïåÎ†§Ï§ò/Î≠êÏïº?"** - Ï∂©Ïã§Ìïú ÏßàÎ¨∏ ÎãµÎ≥Ä
‚Ä¢ üñºÔ∏è **ÏÇ¨ÏßÑÏóê ÎãµÏû•** - Ïù¥ÎØ∏ÏßÄ Ìé∏Ïßë Î∞è ÏàòÏ†ï

üìù **NEW! ÎåÄÌôî Ï∂îÏ†Å Î∞è ÏöîÏïΩ Í∏∞Îä•:**
‚Ä¢ **"ÎèÑÎπÑÏïº, ÎåÄÌôî Ï∂îÏ†Å ÏãúÏûëÌï¥Ï§ò"** - Ï§ëÏöîÌïú ÎåÄÌôî Í∏∞Î°ù ÏãúÏûë
‚Ä¢ **"ÎèÑÎπÑÏïº, ÎåÄÌôî Ï∂îÏ†Å Í∑∏ÎßåÌï¥Ï§ò"** - Ï∂îÏ†Å Ï§ëÎã®
‚Ä¢ **"ÎèÑÎπÑÏïº, ÏöîÏïΩÌï¥Ï§ò"** - Ï∂îÏ†ÅÎêú ÎåÄÌôîÎ•º ÎòëÎòëÌïòÍ≤å ÏöîÏïΩ
‚Ä¢ üìä Í∞úÏù∏Î≥Ñ Ï∂îÏ†Å - Í∞ÅÏûê ÏõêÌïòÎäî ÎåÄÎ°ú Ï∂îÏ†Å Í∞ÄÎä•

ü§ñ **ÏùºÎ∞ò AI Í∏∞Îä•:**
‚Ä¢ /ask [ÏßàÎ¨∏] - Î™ÖÏãúÏ†Å ÏßàÎ¨∏ÌïòÍ∏∞
‚Ä¢ /image [ÏÑ§Î™Ö] - Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±
‚Ä¢ /help - ÏÇ¨Ïö©Î≤ï Î≥¥Í∏∞
‚Ä¢ /version - Î≤ÑÏ†Ñ Í∏∞Î°ù ÌôïÏù∏
‚Ä¢ ÏûêÎèô ÏßàÎ¨∏ Í∞êÏßÄ - ÏßàÎ¨∏ÌïòÎ©¥ Î∞îÎ°ú ÎãµÎ≥Ä

üéØ **Ï∂îÏ†Å ÏãúÏä§ÌÖú Î™ÖÎ†πÏñ¥:**
‚Ä¢ /track_start - ÎåÄÌôî Ï∂îÏ†Å ÏãúÏûë
‚Ä¢ /track_stop - ÎåÄÌôî Ï∂îÏ†Å Ï§ëÎã®
‚Ä¢ /summarize - ÎåÄÌôî ÏöîÏïΩ ÏÉùÏÑ±
‚Ä¢ /track_status - ÌòÑÏû¨ Ï∂îÏ†Å ÏÉÅÌÉú ÌôïÏù∏

üßô‚Äç‚ôÄÔ∏è **ÎèÑÎπÑ ÏÇ¨Ïö© ÏòàÏãú:**
‚Ä¢ "ÎèÑÎπÑÏïº, Í∑ÄÏó¨Ïö¥ Í∞ïÏïÑÏßÄ Í∑∏Î†§Ï§ò"
‚Ä¢ "ÎèÑÎπÑÏïº, ÌååÏù¥Ïç¨ Í≥µÎ∂ÄÎ≤ï ÏïåÎ†§Ï§ò"
‚Ä¢ "ÎèÑÎπÑÏïº, ÎåÄÌôî Ï∂îÏ†Å ÏãúÏûëÌï¥Ï§ò"
‚Ä¢ "ÎèÑÎπÑÏïº, ÏöîÏïΩÌï¥Ï§ò"
‚Ä¢ "ÎèÑÎπÑÏïº, ÏÇ¨Ïö©Î≤ï ÏïåÎ†§Ï§ò"

‚ú® **ÎèÑÎπÑÏùò ÌäπÎ≥ÑÌï®:**
‚Ä¢ üé≠ Ìï¥Î¶¨Ìè¨ÌÑ∞ ÎèÑÎπÑ Ï∫êÎ¶≠ÌÑ∞ Ïä§ÌÉÄÏùº
‚Ä¢ üè† "Ï£ºÏù∏Îãò"ÏùÑ ÏúÑÌïú Ï∂©Ïã§Ìïú ÏÑúÎπÑÏä§
‚Ä¢ üîÆ ÎßàÎ≤ïÍ∞ôÏùÄ AI Îä•Î†• (Google Imagen 4.0 + Claude 3.5)
‚Ä¢ üìö ÎòëÎòëÌïú ÎåÄÌôî ÏöîÏïΩ (Í∞úÏù∏Î≥Ñ ÎßûÏ∂§)

üéØ **ÎèÑÎπÑÎäî Ïñ∏Ï†úÎÇò Ï§ÄÎπÑÎêòÏñ¥ ÏûàÏäµÎãàÎã§!**
"ÎèÑÎπÑÏïº"ÎùºÍ≥† Î∂àÎü¨Ï£ºÏãúÎ©¥ Ï¶âÏãú Îã¨Î†§Í∞ëÎãàÎã§! üèÉ‚Äç‚ôÇÔ∏è‚ú®`;
  } catch (error) {
    console.error('Error getting help message:', error);
    // Fallback to basic message
    return `üßô‚Äç‚ôÄÔ∏è **ÎèÑÎπÑ AI Î¥áÏûÖÎãàÎã§!** üè†

ü§ñ **ÎèÑÎπÑ Î¥á v1.0.0** (Í∞úÎ∞ú Ï§ë)

üåü **ÎèÑÎπÑ Í∞úÏù∏ÎπÑÏÑú Î™®Îìú:**
‚Ä¢ üé® **"ÎèÑÎπÑÏïº, ~~~ Í∑∏Î†§Ï§ò"** - ÎßàÎ≤ïÍ∞ôÏùÄ Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±
‚Ä¢ üí¨ **"ÎèÑÎπÑÏïº, ~~~ ÏïåÎ†§Ï§ò/Î≠êÏïº?"** - Ï∂©Ïã§Ìïú ÏßàÎ¨∏ ÎãµÎ≥Ä
‚Ä¢ üñºÔ∏è **ÏÇ¨ÏßÑÏóê ÎãµÏû•** - Ïù¥ÎØ∏ÏßÄ Ìé∏Ïßë Î∞è ÏàòÏ†ï

üìù **ÎåÄÌôî Ï∂îÏ†Å Î∞è ÏöîÏïΩ Í∏∞Îä•:**
‚Ä¢ **"ÎèÑÎπÑÏïº, ÎåÄÌôî Ï∂îÏ†Å ÏãúÏûëÌï¥Ï§ò"** - Ï§ëÏöîÌïú ÎåÄÌôî Í∏∞Î°ù ÏãúÏûë
‚Ä¢ **"ÎèÑÎπÑÏïº, ÎåÄÌôî Ï∂îÏ†Å Í∑∏ÎßåÌï¥Ï§ò"** - Ï∂îÏ†Å Ï§ëÎã®
‚Ä¢ **"ÎèÑÎπÑÏïº, ÏöîÏïΩÌï¥Ï§ò"** - Ï∂îÏ†ÅÎêú ÎåÄÌôîÎ•º ÎòëÎòëÌïòÍ≤å ÏöîÏïΩ

üéØ **ÎèÑÎπÑÎäî Ïñ∏Ï†úÎÇò Ï§ÄÎπÑÎêòÏñ¥ ÏûàÏäµÎãàÎã§!**
"ÎèÑÎπÑÏïº"ÎùºÍ≥† Î∂àÎü¨Ï£ºÏãúÎ©¥ Ï¶âÏãú Îã¨Î†§Í∞ëÎãàÎã§! üèÉ‚Äç‚ôÇÔ∏è‚ú®`;
  }
}

// =============================================================================
// üì∏ PHOTO UPLOAD HANDLER - New Photo Editing Flow
// =============================================================================

bot.on('message:photo', async (ctx) => {
  try {
    console.log('üì∏ Photo received from user');

    // Handle photo upload
    const uploadResult = await handlePhotoUpload(ctx);

    if (!uploadResult.success) {
      await ctx.reply(`‚ùå ÏÇ¨ÏßÑ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.\n\n${uploadResult.error}`);
      return;
    }

    console.log('‚úÖ Photo processed successfully:', uploadResult.imageUrl);

    // Build message with analysis and recommendations
    let message = `‚úÖ **ÏÇ¨ÏßÑÏùÑ Î∞õÏïòÏñ¥Ïöî!**\n\n`;
    message += `üîç **Î∂ÑÏÑù Í≤∞Í≥º:**\n${uploadResult.analysisSummary || 'Î∂ÑÏÑù Ï§ë...'}\n\n`;
    message += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;

    // Add recommendations with inline buttons
    if (uploadResult.recommendations && uploadResult.recommendations.length > 0) {
      message += `üéØ **Ï∂îÏ≤ú Ïä§ÌÉÄÏùº** (Ï†ÅÌï©ÎèÑ Ïàú):\n\n`;

      uploadResult.recommendations.slice(0, 4).forEach((rec, index) => {
        const stars = '‚≠ê'.repeat(Math.ceil(rec.confidence / 25));
        message += `${rec.emoji} **${rec.nameKo}** ${stars}\n`;
        message += `   ‚Ü≥ ${rec.reason} (${rec.confidence}%)\n\n`;
      });

      message += `\nüí° **ÏïÑÎûò Î≤ÑÌäºÏùÑ ÎàåÎü¨ Ïä§ÌÉÄÏùºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî:**\n`;

      // Store file ID in cache with short key
      const fileKey = storeFileId(ctx.chat!.id, ctx.message!.message_id, uploadResult.fileId!);

      // Create inline keyboard with template buttons
      const keyboard = new InlineKeyboard();

      uploadResult.recommendations.slice(0, 4).forEach(rec => {
        keyboard.text(
          `${rec.emoji} ${rec.nameKo}`,
          `t:${rec.templateKey}:${fileKey}`
        ).row();
      });

      // Add "View All" button
      keyboard.text('üîç Ï†ÑÏ≤¥ 38Í∞ú Ïä§ÌÉÄÏùº Î≥¥Í∏∞', `t:all:${fileKey}`);

      await ctx.reply(message, {
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });
    } else {
      message += `üì∏ **Ìé∏Ïßë ÏòµÏÖò:**\n`;
      message += `‚Ä¢ /edit - AI Ïä§ÌÉÄÏùº Ìé∏Ïßë\n`;
      message += `‚Ä¢ ÎãµÏû•ÏúºÎ°ú "ÎèÑÎπÑÏïº [ÏöîÏ≤≠]" - ÏßÅÏ†ë Ìé∏Ïßë\n`;

      await ctx.reply(message, { parse_mode: 'Markdown' });
    }

    // TODO: Next steps
    // 1. ‚úÖ Analyze image (DONE)
    // 2. ‚úÖ Recommend templates (DONE)
    // 3. ‚úÖ Show inline buttons (DONE)
    // 4. Handle button clicks (below)

  } catch (error) {
    console.error('‚ùå Error in photo handler:', error);
    await ctx.reply('‚ùå ÏÇ¨ÏßÑ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
  }
});

// =============================================================================
// CALLBACK QUERY HANDLERS (Inline Buttons)
// =============================================================================

// In-memory storage for file IDs (session-based)
const fileIdCache = new Map<string, string>();

function storeFileId(chatId: number, messageId: number, fileId: string): string {
  const key = `${chatId}:${messageId}`;
  fileIdCache.set(key, fileId);
  return key;
}

function getFileId(key: string): string | undefined {
  return fileIdCache.get(key);
}

// Template selection callback handler
bot.callbackQuery(/^t:([^:]+):(.+):(.+)$/, async (ctx) => {
  try {
    const templateKey = ctx.match[1];
    const chatId = parseInt(ctx.match[2]);
    const messageId = parseInt(ctx.match[3]);
    const fileKey = `${chatId}:${messageId}`;

    // Try to get from cache first
    let fileId = getFileId(fileKey);

    // If not in cache, retrieve from database using message_id
    if (!fileId) {
      console.log(`üîç FileId not in cache, retrieving from database for message ${messageId}...`);

      const { data, error } = await supabase
        .from('image_analysis_results')
        .select('analysis_data')
        .eq('message_id', messageId)
        .single();

      if (error || !data) {
        await ctx.answerCallbackQuery('Ïù¥ÎØ∏ÏßÄ Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. ÏÇ¨ÏßÑÏùÑ Îã§Ïãú ÏóÖÎ°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.');
        return;
      }

      fileId = data.analysis_data?.file_id;

      if (!fileId) {
        await ctx.answerCallbackQuery('ÌååÏùº IDÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. ÏÇ¨ÏßÑÏùÑ Îã§Ïãú ÏóÖÎ°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.');
        return;
      }

      // Store in cache for future use
      storeFileId(chatId, messageId, fileId);
      console.log(`‚úÖ FileId retrieved from database and cached: ${fileId}`);
    }

    console.log(`üé® Template selected: ${templateKey} for file: ${fileId}`);

    // Answer callback to remove loading state
    await ctx.answerCallbackQuery();

    // Handle "View All" button
    if (templateKey === 'all') {
      // Fetch all templates from database
      const { data: allTemplates, error } = await supabase
        .from('prompt_templates')
        .select('*')
        .eq('is_active', true)
        .order('priority', { ascending: false });

      if (error || !allTemplates) {
        await ctx.reply('‚ùå ÌÖúÌîåÎ¶ø Î™©Î°ùÏùÑ Í∞ÄÏ†∏Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
        return;
      }

      // Create paginated keyboard with all templates (8 per page)
      const keyboard = new InlineKeyboard();
      const templatesPerPage = 8;
      const templates = allTemplates.slice(0, templatesPerPage);

      templates.forEach(template => {
        const emoji = getCategoryEmoji(template.category);
        keyboard.text(
          `${emoji} ${template.template_name_ko}`,
          `t:${template.template_key}:${fileKey}`
        ).row();
      });

      // Add pagination if more than 8 templates
      if (allTemplates.length > templatesPerPage) {
        keyboard.text('‚û°Ô∏è Îã§Ïùå ÌéòÏù¥ÏßÄ', `tp:1:${fileKey}`);
      }

      await ctx.reply('üé® **Ï†ÑÏ≤¥ Ïä§ÌÉÄÏùº Î™©Î°ù:**\n\nÏõêÌïòÎäî Ïä§ÌÉÄÏùºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî:', {
        reply_markup: keyboard
      });
      return;
    }

    // Fetch selected template from database
    const { data: template, error } = await supabase
      .from('prompt_templates')
      .select('*')
      .eq('template_key', templateKey)
      .single();

    if (error || !template) {
      await ctx.reply('‚ùå ÏÑ†ÌÉùÌïú ÌÖúÌîåÎ¶øÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
      return;
    }

    // Get image URL from fileId
    const file = await ctx.api.getFile(fileId);
    if (!file.file_path) {
      await ctx.reply('‚ùå ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
      return;
    }

    const imageUrl = `https://api.telegram.org/file/bot${BOT_TOKEN}/${file.file_path}`;

    // Send processing message
    const processingMsg = await ctx.reply(
      `‚ú® **${template.template_name_ko}** Ïä§ÌÉÄÏùºÎ°ú Ìé∏Ïßë Ï§ë...\n\n` +
      `üé® AIÍ∞Ä ÏûëÏóÖ Ï§ëÏûÖÎãàÎã§. Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî...`
    );

    console.log('üìã Template details:', {
      name: template.template_name_ko,
      category: template.category,
      prompt: template.base_prompt.substring(0, 100) + '...'
    });

    // Execute image editing with Replicate
    const { editImageWithReplicate } = await import('../../src/services/image-edit-service');

    const editResult = await editImageWithReplicate({
      imageUrl,
      templatePrompt: template.base_prompt,
      templateName: template.template_name_ko,
      category: template.category
    });

    if (editResult.success && editResult.outputUrl) {
      // Update processing message
      await ctx.api.editMessageText(
        ctx.chat!.id,
        processingMsg.message_id,
        `‚úÖ **Ìé∏Ïßë ÏôÑÎ£å!**\n\n` +
        `üé® Ïä§ÌÉÄÏùº: ${template.template_name_ko}\n` +
        `‚è±Ô∏è Ï≤òÎ¶¨ ÏãúÍ∞Ñ: ${Math.round(editResult.processingTime! / 1000)}Ï¥à\n\n` +
        `Í≤∞Í≥ºÎ•º Ï†ÑÏÜ°Ìï©ÎãàÎã§...`
      );

      // Create action buttons for the edited image
      const actionKeyboard = new InlineKeyboard()
        .text('üîÑ Îã§Î•∏ Ïä§ÌÉÄÏùº ÏãúÎèÑ', `retry:${fileKey}`)
        .text('üíæ ÏõêÎ≥∏ÏúºÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞', `back:${fileKey}`).row()
        .text('üé® Îã§Ïãú Ìé∏Ïßë', `redo:${template.template_key}:${fileKey}`)
        .text('‚≠ê Ïù¥ Ïä§ÌÉÄÏùº ÌèâÍ∞Ä', `rate:${template.template_key}`);

      // Send edited image with action buttons
      await ctx.replyWithPhoto(editResult.outputUrl, {
        caption: `‚ú® **${template.template_name_ko}** Ïä§ÌÉÄÏùº Ìé∏Ïßë ÏôÑÎ£å!\n\n` +
          `üìù ÌîÑÎ°¨ÌîÑÌä∏: ${template.base_prompt.substring(0, 100)}...\n` +
          `‚è±Ô∏è ${Math.round(editResult.processingTime! / 1000)}Ï¥à ÏÜåÏöî\n\n` +
          `üí° **Îã§Ïùå Ïï°ÏÖò:**\n` +
          `‚Ä¢ üîÑ Îã§Î•∏ Ïä§ÌÉÄÏùºÎ°ú ÏãúÎèÑÌï¥Î≥¥ÏÑ∏Ïöî\n` +
          `‚Ä¢ üíæ ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄÎ°ú ÎèåÏïÑÍ∞à Ïàò ÏûàÏäµÎãàÎã§\n` +
          `‚Ä¢ üé® Í∞ôÏùÄ Ïä§ÌÉÄÏùºÎ°ú Îã§Ïãú Ìé∏ÏßëÌï† Ïàò ÏûàÏäµÎãàÎã§`,
        reply_markup: actionKeyboard
      });

      // Store edit result in database
      const { data: editRecord } = await supabase
        .from('image_edit_results')
        .insert({
          user_id: ctx.from?.id,
          chat_id: ctx.chat?.id,
          template_key: template.template_key,
          original_image_url: imageUrl,
          edited_image_url: editResult.outputUrl,
          processing_time_ms: editResult.processingTime,
          status: 'completed'
        })
        .select()
        .single();

      console.log('‚úÖ Edit result stored in database:', editRecord?.id);

    } else {
      // Handle error
      const errorMsg = editResult.error || 'Unknown error';

      await ctx.api.editMessageText(
        ctx.chat!.id,
        processingMsg.message_id,
        `‚ùå **Ìé∏Ïßë Ïã§Ìå®**\n\n` +
        `Ïò§Î•ò: ${errorMsg}\n\n` +
        `üí° Îã§Î•∏ Ïä§ÌÉÄÏùºÏùÑ ÏãúÎèÑÌïòÍ±∞ÎÇò ÎÇòÏ§ëÏóê Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.`
      );

      console.error('‚ùå Edit failed:', errorMsg);
    }

  } catch (error) {
    console.error('‚ùå Error in template callback:', error);
    await ctx.reply('‚ùå ÌÖúÌîåÎ¶ø ÏÑ†ÌÉù Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
  }
});

// Action button handlers for edited images

// Retry edit with different style
bot.callbackQuery(/^retry:(.+):(.+)$/, async (ctx) => {
  try {
    const chatId = parseInt(ctx.match[1]);
    const messageId = parseInt(ctx.match[2]);
    const fileKey = `${chatId}:${messageId}`;

    let fileId = getFileId(fileKey);

    if (!fileId) {
      const { data } = await supabase
        .from('image_analysis_results')
        .select('analysis_data')
        .eq('message_id', messageId)
        .single();

      fileId = data?.analysis_data?.file_id;
      if (fileId) storeFileId(chatId, messageId, fileId);
    }

    if (!fileId) {
      await ctx.answerCallbackQuery('ÏÑ∏ÏÖòÏù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§.');
      return;
    }

    await ctx.answerCallbackQuery();

    // Get file and analysis
    const file = await ctx.api.getFile(fileId);
    if (!file.file_path) {
      await ctx.reply('‚ùå ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
      return;
    }

    const imageUrl = `https://api.telegram.org/file/bot${BOT_TOKEN}/${file.file_path}`;

    // Re-run analysis and show recommendations
    const { analyzeImage } = await import('../../src/services/image-analysis-service');
    const { getTemplateRecommendations } = await import('../../src/services/template-recommendation-service');

    const analysis = await analyzeImage(imageUrl);
    const recommendations = await getTemplateRecommendations(analysis, 5);

    // Show new recommendations
    let message = `üîÑ **Îã§Î•∏ Ïä§ÌÉÄÏùº Ï∂îÏ≤ú**\n\n`;
    const keyboard = new InlineKeyboard();

    recommendations.slice(0, 4).forEach(rec => {
      message += `${rec.emoji} ${rec.nameKo} (${rec.confidence}%)\n`;
      keyboard.text(
        `${rec.emoji} ${rec.nameKo}`,
        `t:${rec.templateKey}:${fileKey}`
      ).row();
    });

    keyboard.text('üîç Ï†ÑÏ≤¥ 38Í∞ú Ïä§ÌÉÄÏùº Î≥¥Í∏∞', `t:all:${fileKey}`);

    await ctx.reply(message, { reply_markup: keyboard });

  } catch (error) {
    console.error('‚ùå Error in retry_edit:', error);
    await ctx.reply('‚ùå Îã§Î•∏ Ïä§ÌÉÄÏùº Ï∂îÏ≤ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
  }
});

// Back to original image
bot.callbackQuery(/^back:(.+):(.+)$/, async (ctx) => {
  try {
    const chatId = parseInt(ctx.match[1]);
    const messageId = parseInt(ctx.match[2]);
    const fileKey = `${chatId}:${messageId}`;

    let fileId = getFileId(fileKey);

    if (!fileId) {
      const { data } = await supabase
        .from('image_analysis_results')
        .select('analysis_data')
        .eq('message_id', messageId)
        .single();

      fileId = data?.analysis_data?.file_id;
      if (fileId) storeFileId(chatId, messageId, fileId);
    }

    if (!fileId) {
      await ctx.answerCallbackQuery('ÏÑ∏ÏÖòÏù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§.');
      return;
    }

    await ctx.answerCallbackQuery('ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄÎ•º Îã§Ïãú Ï†ÑÏÜ°Ìï©ÎãàÎã§...');

    const file = await ctx.api.getFile(fileId);
    if (!file.file_path) {
      await ctx.reply('‚ùå ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
      return;
    }

    const imageUrl = `https://api.telegram.org/file/bot${BOT_TOKEN}/${file.file_path}`;

    await ctx.replyWithPhoto(imageUrl, {
      caption: 'üì∏ **ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄ**\n\nÎã§Ïãú Ìé∏ÏßëÌïòÏãúÎ†§Î©¥ ÏúÑÏùò Ï∂îÏ≤ú Î≤ÑÌäºÏùÑ ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî.'
    });

  } catch (error) {
    console.error('‚ùå Error in back_to_original:', error);
    await ctx.reply('‚ùå ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄ Ï†ÑÏÜ° Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
  }
});

// Re-edit with same style
bot.callbackQuery(/^redo:([^:]+):(.+):(.+)$/, async (ctx) => {
  try {
    const templateKey = ctx.match[1];
    const chatId = parseInt(ctx.match[2]);
    const messageId = parseInt(ctx.match[3]);
    const fileKey = `${chatId}:${messageId}`;

    let fileId = getFileId(fileKey);

    if (!fileId) {
      const { data } = await supabase
        .from('image_analysis_results')
        .select('analysis_data')
        .eq('message_id', messageId)
        .single();

      fileId = data?.analysis_data?.file_id;
      if (fileId) storeFileId(chatId, messageId, fileId);
    }

    if (!fileId) {
      await ctx.answerCallbackQuery('ÏÑ∏ÏÖòÏù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§.');
      return;
    }

    await ctx.answerCallbackQuery('Í∞ôÏùÄ Ïä§ÌÉÄÏùºÎ°ú Îã§Ïãú Ìé∏ÏßëÌï©ÎãàÎã§...');

    // Fetch template
    const { data: template, error } = await supabase
      .from('prompt_templates')
      .select('*')
      .eq('template_key', templateKey)
      .single();

    if (error || !template) {
      await ctx.reply('‚ùå ÌÖúÌîåÎ¶øÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
      return;
    }

    // Get image URL
    const file = await ctx.api.getFile(fileId);
    if (!file.file_path) {
      await ctx.reply('‚ùå ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
      return;
    }

    const imageUrl = `https://api.telegram.org/file/bot${BOT_TOKEN}/${file.file_path}`;

    // Execute editing (same logic as template selection)
    const processingMsg = await ctx.reply(
      `üé® **${template.template_name_ko}** Ïä§ÌÉÄÏùºÎ°ú Îã§Ïãú Ìé∏Ïßë Ï§ë...\n\n` +
      `‚ö° Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî...`
    );

    const { editImageWithReplicate } = await import('../../src/services/image-edit-service');

    const editResult = await editImageWithReplicate({
      imageUrl,
      templatePrompt: template.base_prompt,
      templateName: template.template_name_ko,
      category: template.category
    });

    if (editResult.success && editResult.outputUrl) {
      await ctx.api.editMessageText(
        ctx.chat!.id,
        processingMsg.message_id,
        `‚úÖ Ìé∏Ïßë ÏôÑÎ£å!`
      );

      const actionKeyboard = new InlineKeyboard()
        .text('üîÑ Îã§Î•∏ Ïä§ÌÉÄÏùº ÏãúÎèÑ', `retry:${fileKey}`)
        .text('üíæ ÏõêÎ≥∏ÏúºÎ°ú ÎèåÏïÑÍ∞ÄÍ∏∞', `back:${fileKey}`).row()
        .text('üé® Îã§Ïãú Ìé∏Ïßë', `redo:${template.template_key}:${fileKey}`)
        .text('‚≠ê Ïù¥ Ïä§ÌÉÄÏùº ÌèâÍ∞Ä', `rate:${template.template_key}`);

      await ctx.replyWithPhoto(editResult.outputUrl, {
        caption: `‚ú® **${template.template_name_ko}** Ïû¨Ìé∏Ïßë ÏôÑÎ£å!`,
        reply_markup: actionKeyboard
      });
    } else {
      await ctx.api.editMessageText(
        ctx.chat!.id,
        processingMsg.message_id,
        `‚ùå Ìé∏Ïßë Ïã§Ìå®: ${editResult.error}`
      );
    }

  } catch (error) {
    console.error('‚ùå Error in re_edit:', error);
    await ctx.reply('‚ùå Ïû¨Ìé∏Ïßë Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
  }
});

// Rate style
bot.callbackQuery(/^rate:(.+)$/, async (ctx) => {
  try {
    const templateKey = ctx.match[1];
    await ctx.answerCallbackQuery();

    const ratingKeyboard = new InlineKeyboard()
      .text('‚≠ê 1Ï†ê', `rating:${templateKey}:1`)
      .text('‚≠ê‚≠ê 2Ï†ê', `rating:${templateKey}:2`)
      .text('‚≠ê‚≠ê‚≠ê 3Ï†ê', `rating:${templateKey}:3`).row()
      .text('‚≠ê‚≠ê‚≠ê‚≠ê 4Ï†ê', `rating:${templateKey}:4`)
      .text('‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê 5Ï†ê', `rating:${templateKey}:5`);

    await ctx.reply('‚≠ê **Ïù¥ Ïä§ÌÉÄÏùºÏùÑ ÌèâÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî:**\n\nÎ≥ÑÏ†êÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî:', {
      reply_markup: ratingKeyboard
    });

  } catch (error) {
    console.error('‚ùå Error in rate_style:', error);
    await ctx.reply('‚ùå ÌèâÍ∞Ä ÏöîÏ≤≠ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
  }
});

// Submit rating
bot.callbackQuery(/^rating:(.+):(\d+)$/, async (ctx) => {
  try {
    const templateKey = ctx.match[1];
    const rating = parseInt(ctx.match[2]);

    await ctx.answerCallbackQuery(`${rating}Ï†êÏúºÎ°ú ÌèâÍ∞ÄÌï¥Ï£ºÏÖîÏÑú Í∞êÏÇ¨Ìï©ÎãàÎã§! ‚≠ê`);

    // Store rating (optional - can add rating table later)
    console.log(`üìä User ${ctx.from?.id} rated ${templateKey}: ${rating} stars`);

    await ctx.reply(`‚úÖ **ÌèâÍ∞Ä ÏôÑÎ£å!**\n\n${templateKey} Ïä§ÌÉÄÏùºÏóê ${rating}Ï†êÏùÑ Ï£ºÏÖ®ÏäµÎãàÎã§. Í∞êÏÇ¨Ìï©ÎãàÎã§! üôè`);

  } catch (error) {
    console.error('‚ùå Error in submit_rating:', error);
  }
});

// Helper function to get category emoji
function getCategoryEmoji(category: string): string {
  const emojiMap: Record<string, string> = {
    '3d_figurine': 'üé≠',
    'portrait_styling': 'üì∏',
    'game_animation': 'üéÆ',
    'image_editing': 'üõ†Ô∏è',
    'creative_transform': '‚ú®'
  };
  return emojiMap[category] || 'üé®';
}

// Bot commands
bot.command('start', async (ctx) => {
  console.log('üì® Start command received');
  const helpMessage = await getHelpMessage();
  await ctx.reply(helpMessage);
});

// Help command - shows same content as start
bot.command('help', async (ctx) => {
  console.log('‚ùì Help command received');
  const helpMessage = await getHelpMessage();
  await ctx.reply(helpMessage);
});

// Version command - shows version history
bot.command('version', async (ctx) => {
  console.log('üìö Version command received');

  try {
    const versionHistory = await getFormattedVersionHistory(5);
    await ctx.reply(`${versionHistory}

üí° **Î™ÖÎ†πÏñ¥:**
‚Ä¢ /version - ÏµúÍ∑º 5Í∞ú Î≤ÑÏ†Ñ Î≥¥Í∏∞
‚Ä¢ /help - ÏÇ¨Ïö©Î≤ï Î≥¥Í∏∞

üè† ÎèÑÎπÑÍ∞Ä ÏßÄÏÜçÏ†ÅÏúºÎ°ú Î∞úÏ†ÑÌïòÍ≥† ÏûàÏäµÎãàÎã§!`);

  } catch (error) {
    console.error('Error fetching version history:', error);
    await ctx.reply(`‚ùå **Î≤ÑÏ†Ñ Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§**

${(error as Error).message}

üí° Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.`);
  }
});

bot.command('test', async (ctx) => {
  console.log('üß™ Test command received');
  await ctx.reply(`üß™ ÌîÑÎ°úÎçïÏÖò ÌÖåÏä§Ìä∏ ÏÑ±Í≥µ!

üåê Î∞∞Ìè¨ ÌôòÍ≤Ω:
‚Ä¢ ÌîåÎû´Ìèº: ‚úÖ Netlify Functions
‚Ä¢ ÌÜµÏã† Î∞©Ïãù: ‚úÖ Webhook (Ïã§ÏãúÍ∞Ñ)
‚Ä¢ Claude API: ‚úÖ ${CLAUDE_API_KEY ? 'Ïó∞Í≤∞Îê®' : '‚ùå ÎØ∏Ïó∞Í≤∞'}
‚Ä¢ Google Imagen: ‚úÖ ${GOOGLE_API_KEY ? 'Ïó∞Í≤∞Îê®' : '‚ùå ÎØ∏Ïó∞Í≤∞'}

‚è∞ ÏÑúÎ≤Ñ ÏãúÍ∞Ñ: ${new Date().toISOString()}
üåç Ìï≠ÏÉÅ Ïò®ÎùºÏù∏ ÏÉÅÌÉúÎ°ú Ïö¥ÏòÅÎê©ÎãàÎã§!`);
});

bot.command('summary', async (ctx) => {
  console.log('üìù Summary command received');
  try {
    const claudeResponse = await callClaudeAPI('ÏïàÎÖïÌïòÏÑ∏Ïöî! ÌîÑÎ°úÎçïÏÖò ÌôòÍ≤ΩÏóêÏÑú ÌÖåÏä§Ìä∏ÏûÖÎãàÎã§. ÌïúÍµ≠Ïñ¥Î°ú ÏßßÍ≤å Ïù∏ÏÇ¨Ìï¥Ï£ºÏÑ∏Ïöî.');
    await ctx.reply(`üéâ Claude API ÌîÑÎ°úÎçïÏÖò ÌÖåÏä§Ìä∏ ÏÑ±Í≥µ!

ClaudeÏùò ÏùëÎãµ:
${claudeResponse.text}

üí∞ ÎπÑÏö©: ${formatCost(claudeResponse.cost)}
‚è±Ô∏è Ï≤òÎ¶¨ÏãúÍ∞Ñ: ${claudeResponse.processingTime}ms
üî§ ÌÜ†ÌÅ∞ ÏÇ¨Ïö©Îüâ: ${claudeResponse.inputTokens} ‚Üí ${claudeResponse.outputTokens}

‚úÖ ÏÑúÎ≤ÑÎ¶¨Ïä§ ÌôòÍ≤ΩÏóêÏÑú AI Ïó∞Îèô ÏôÑÎ£å!`);

  } catch (error) {
    await handleError(ctx, error as Error, 'Claude API ÌÖåÏä§Ìä∏');
  }
});

bot.command('image', async (ctx) => {
  const prompt = ctx.message?.text?.replace('/image', '').trim() || '';
  if (!prompt) {
    await ctx.reply(`üé® **Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± ÏÇ¨Ïö©Î≤ï:**\n\n/image [ÏÉÅÏÑ∏Ìïú ÏÑ§Î™Ö]\n\nÏòàÏãú:\n‚Ä¢ /image ÎØ∏ÎûòÏ†ÅÏù∏ Î°úÎ¥á Í∞úÎ∞úÏûê`);
    return;
  }

  console.log(`üé® Image generation requested: "${prompt}"`);
  const generatingMessage = await ctx.reply(`üé® Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ï§ë...\n\nÌîÑÎ°¨ÌîÑÌä∏: "${prompt}"`);

  try {
    const imageResult = await generateImageWithImagen(prompt, false, ctx.from?.id?.toString(), ctx.chat?.id?.toString());

    // Create buffer from base64

    const imageBuffer = Buffer.from(imageResult.imageData.replace(/^data:image\/[a-z]+;base64,/, ''), 'base64');

    await ctx.replyWithPhoto(new InputFile(imageBuffer, `generated_${Date.now()}.png`), {
      caption: `üé® ÌîÑÎ°úÎçïÏÖò Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± ÏôÑÎ£å!

ÌîÑÎ°¨ÌîÑÌä∏: "${prompt}"

‚ú® Google Imagen 4.0
üåê Netlify Functions
üéØ Ìï¥ÏÉÅÎèÑ: 1024x1024
üí∞ ÎπÑÏö©: ${formatCost(imageResult.cost)}
‚è±Ô∏è Ï≤òÎ¶¨ÏãúÍ∞Ñ: ${imageResult.processingTime}ms
üìÖ ${new Date().toLocaleString('ko-KR')}`

    });

    await ctx.api.deleteMessage(ctx.chat.id, generatingMessage.message_id);
    console.log('‚úÖ Image sent successfully!');
  } catch (error) {
    await handleError(ctx, error as Error, 'Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±', generatingMessage);
  }
});

// Generate command for image creation (also used for 2-stage editing)
bot.command('generate', async (ctx) => {
  const prompt = ctx.message?.text?.replace('/generate', '').trim() || '';

  if (!prompt) {
    await ctx.reply(`üé® **Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± ÏÇ¨Ïö©Î≤ï:**

/generate [ÌîÑÎ°¨ÌîÑÌä∏]

ÏòàÏãú:
‚Ä¢ /generate Í∑ÄÏó¨Ïö¥ Í∞ïÏïÑÏßÄÍ∞Ä Í≥µÏõêÏóêÏÑú ÎÖ∏Îäî Î™®Ïäµ
‚Ä¢ /generate futuristic city with flying cars
‚Ä¢ /generate ÏïÑÎ¶ÑÎã§Ïö¥ ÏùºÎ™∞Ïù¥ ÏûàÎäî Ìï¥Î≥Ä

üí° **Ïù¥ÎØ∏ÏßÄ Ìé∏Ïßë ÌõÑ ÏÇ¨Ïö©:**
Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù ÌõÑ Ï†úÍ≥µÎêú ÌîÑÎ°¨ÌîÑÌä∏Î°ú ÏÉùÏÑ± Í∞ÄÎä•`);
    return;
  }

  console.log(`üé® Generating image with prompt: "${prompt}"`);
  const generatingMessage = await ctx.reply(`üé® **Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ï§ë...**

üìù ÌîÑÎ°¨ÌîÑÌä∏: "${prompt}"
ü§ñ AI: Google Imagen 4.0
‚ö° Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî...`);

  try {
    const imageResult = await generateImageWithImagen(prompt, false, ctx.from?.id?.toString(), ctx.chat?.id?.toString());

    // Create buffer from base64
    const imageBuffer = Buffer.from(imageResult.imageData.replace(/^data:image\/[a-z]+;base64,/, ''), 'base64');

    await ctx.replyWithPhoto(new InputFile(imageBuffer, `generated_${Date.now()}.png`), {
      caption: `üé® **Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± ÏôÑÎ£å!**

üìù **ÌîÑÎ°¨ÌîÑÌä∏**: "${prompt}"
‚ú® **AI**: Google Imagen 4.0
üí∞ **ÎπÑÏö©**: ${formatCost(imageResult.cost)}
‚è±Ô∏è **Ï≤òÎ¶¨ÏãúÍ∞Ñ**: ${imageResult.processingTime}ms

üìÖ ${new Date().toLocaleString('ko-KR')}`
    });

    await ctx.api.deleteMessage(ctx.chat.id, generatingMessage.message_id);
    console.log('‚úÖ Image sent successfully!');

  } catch (error) {
    await handleError(ctx, error as Error, 'Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±', generatingMessage);
  }
});

// NSFW Image Generation with Replicate
bot.command('nsfw_imagine', async (ctx) => {
  const prompt = ctx.message?.text?.replace('/nsfw_imagine', '').trim() || '';

  if (!prompt) {
    await ctx.reply(`üîû **NSFW Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± ÏÇ¨Ïö©Î≤ï:**

/nsfw_imagine [ÌîÑÎ°¨ÌîÑÌä∏]

‚ö†Ô∏è **Ï£ºÏùòÏÇ¨Ìï≠:**
‚Ä¢ ÏÑ±Ïù∏Ïö© ÏΩòÌÖêÏ∏† ÏÉùÏÑ± Í∏∞Îä•ÏûÖÎãàÎã§
‚Ä¢ ÏùºÏùº 5Ìöå Ï†úÌïú
‚Ä¢ 20 ÌÜ†ÌÅ∞ ÏÜåÎ™®
‚Ä¢ Ï≤òÎ¶¨ ÏãúÍ∞Ñ: ÏïΩ 30-60Ï¥à

üí° **ÏòàÏãú:**
‚Ä¢ /nsfw_imagine beautiful woman in elegant dress
‚Ä¢ /nsfw_imagine artistic portrait photography

ü§ñ **AI**: Flux.1Dev Uncensored (MSFLUX NSFW v3)`);
    return;
  }

  if (!replicateService.isAvailable()) {
    await ctx.reply(`‚ùå **NSFW ÏÉùÏÑ± Í∏∞Îä•Ïù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§.**

Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Î¨∏ÏùòÌïòÏÑ∏Ïöî.`);
    return;
  }

  console.log(`üîû NSFW image generation requested: "${prompt}"`);

  try {
    // Check daily limit - DISABLED FOR TESTING
    // const { data: limitCheck } = await supabase.rpc('check_nsfw_daily_limit', {
    //   p_user_id: ctx.from!.id
    // });

    // if (!limitCheck) {
    //   await ctx.reply(`‚ùå **ÏùºÏùº ÏÉùÏÑ± Ï†úÌïú Ï¥àÍ≥º**

    // Ïò§ÎäòÏùÄ Ïù¥ÎØ∏ 5ÌöåÏùò NSFW ÏΩòÌÖêÏ∏†Î•º ÏÉùÏÑ±ÌïòÏÖ®ÏäµÎãàÎã§.
    // ÎÇ¥Ïùº Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.`);
    //   return;
    // }

    const generatingMessage = await ctx.reply(`üîû **NSFW Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ï§ë...**

üìù ÌîÑÎ°¨ÌîÑÌä∏: "${prompt}"
ü§ñ AI: Flux.1Dev Uncensored
‚è≥ ÏïΩ 30-60Ï¥à ÏÜåÏöîÎê©ÎãàÎã§...

üîî ÏôÑÎ£åÎêòÎ©¥ ÏïåÎ¶ºÏùÑ Î≥¥ÎÇ¥ÎìúÎ¶ΩÎãàÎã§.`);

    // Create database record
    const { data: generation, error: dbError } = await supabase
      .from('nsfw_generations')
      .insert({
        user_id: ctx.from!.id,
        chat_id: ctx.chat!.id,
        type: 'image',
        prompt: prompt,
        model_version: 'flux-1dev-uncensored',
        status: 'processing'
      })
      .select()
      .single();

    if (dbError) {
      console.error('‚ùå Failed to create generation record:', dbError);
      await ctx.api.editMessageText(
        ctx.chat!.id,
        generatingMessage.message_id,
        '‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.'
      );
      return;
    }

    // Generate image
    const imageUrls = await replicateService.generateNSFWImage(prompt);

    // Update database
    await supabase
      .from('nsfw_generations')
      .update({
        status: 'completed',
        output_url: imageUrls[0],
        completed_at: new Date().toISOString()
      })
      .eq('id', generation.id);

    // Delete processing message
    await ctx.api.deleteMessage(ctx.chat!.id, generatingMessage.message_id);

    // Send result
    for (const url of imageUrls) {
      await ctx.replyWithPhoto(url, {
        caption: imageUrls.length === 1 ? `‚ú® **NSFW Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± ÏôÑÎ£å!**

üìù ÌîÑÎ°¨ÌîÑÌä∏: "${prompt}"
ü§ñ AI: Flux.1Dev Uncensored (MSFLUX NSFW v3)
üí∞ ÎπÑÏö©: 20 ÌÜ†ÌÅ∞

üîû ÏÑ±Ïù∏Ïö© ÏΩòÌÖêÏ∏†ÏûÖÎãàÎã§.` : undefined
      });
    }

    console.log('‚úÖ NSFW image generated successfully!');

  } catch (error) {
    console.error('‚ùå NSFW image generation error:', error);

    // Extract meaningful error message
    let errorMsg = 'Unknown error';
    if (error instanceof Error) {
      if (error.message.includes('403')) {
        errorMsg = 'API Ï†ëÍ∑º Í±∞Î∂Ä (403). Replicate Í≥ÑÏ†ï ÎòêÎäî ÌÜ†ÌÅ∞ÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.';
      } else if (error.message.includes('401')) {
        errorMsg = 'API Ïù∏Ï¶ù Ïã§Ìå®. ÌÜ†ÌÅ∞Ïù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.';
      } else if (error.message.includes('429')) {
        errorMsg = 'API ÏÇ¨Ïö©Îüâ ÌïúÎèÑ Ï¥àÍ≥º. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.';
      } else {
        // Use only first 100 characters of error message
        errorMsg = error.message.substring(0, 100);
      }
    }

    await ctx.reply(`‚ùå **NSFW Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ïã§Ìå®**

Ïò§Î•ò: ${errorMsg}

üí° Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Î¨∏ÏùòÌïòÍ±∞ÎÇò Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.`);
  }
});

// NSFW Video Generation with Replicate
bot.command('nsfw_video', async (ctx) => {
  const prompt = ctx.message?.text?.replace('/nsfw_video', '').trim() || '';

  if (!prompt) {
    await ctx.reply(`üîû **NSFW ÎπÑÎîîÏò§ ÏÉùÏÑ± ÏÇ¨Ïö©Î≤ï:**

/nsfw_video [ÌîÑÎ°¨ÌîÑÌä∏]

‚ö†Ô∏è **Ï£ºÏùòÏÇ¨Ìï≠:**
‚Ä¢ ÏÑ±Ïù∏Ïö© ÎπÑÎîîÏò§ ÏÉùÏÑ± Í∏∞Îä•ÏûÖÎãàÎã§
‚Ä¢ ÏùºÏùº 5Ìöå Ï†úÌïú
‚Ä¢ 30 ÌÜ†ÌÅ∞ ÏÜåÎ™®
‚Ä¢ Ï≤òÎ¶¨ ÏãúÍ∞Ñ: ÏïΩ 2-5Î∂Ñ

üí° **ÏòàÏãú:**
‚Ä¢ /nsfw_video woman walking in the rain
‚Ä¢ /nsfw_video dancer performing on stage

ü§ñ **AI**: Zeroscope V2 XL (Replicate)`);
    return;
  }

  if (!replicateService.isAvailable()) {
    await ctx.reply(`‚ùå **NSFW ÏÉùÏÑ± Í∏∞Îä•Ïù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§.**

Í¥ÄÎ¶¨ÏûêÏóêÍ≤å Î¨∏ÏùòÌïòÏÑ∏Ïöî.`);
    return;
  }

  console.log(`üîû NSFW video generation requested: "${prompt}"`);

  try {
    // Check daily limit - DISABLED FOR TESTING
    // const { data: limitCheck } = await supabase.rpc('check_nsfw_daily_limit', {
    //   p_user_id: ctx.from!.id
    // });

    // if (!limitCheck) {
    //   await ctx.reply(`‚ùå **ÏùºÏùº ÏÉùÏÑ± Ï†úÌïú Ï¥àÍ≥º**

    // Ïò§ÎäòÏùÄ Ïù¥ÎØ∏ 5ÌöåÏùò NSFW ÏΩòÌÖêÏ∏†Î•º ÏÉùÏÑ±ÌïòÏÖ®ÏäµÎãàÎã§.
    // ÎÇ¥Ïùº Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.`);
    //   return;
    // }

    const generatingMessage = await ctx.reply(`üîû **NSFW ÎπÑÎîîÏò§ ÏÉùÏÑ± Ï§ë...**

üìù ÌîÑÎ°¨ÌîÑÌä∏: "${prompt}"
ü§ñ AI: Zeroscope V2 XL
‚è≥ ÏïΩ 2-5Î∂Ñ ÏÜåÏöîÎê©ÎãàÎã§...

üîî ÏôÑÎ£åÎêòÎ©¥ ÏïåÎ¶ºÏùÑ Î≥¥ÎÇ¥ÎìúÎ¶ΩÎãàÎã§.`);

    // Create database record
    const { data: generation, error: dbError } = await supabase
      .from('nsfw_generations')
      .insert({
        user_id: ctx.from!.id,
        chat_id: ctx.chat!.id,
        type: 'video',
        prompt: prompt,
        model_version: 'zeroscope-v2-xl',
        status: 'processing',
        tokens_used: 30
      })
      .select()
      .single();

    if (dbError) {
      console.error('‚ùå Failed to create generation record:', dbError);
      await ctx.api.editMessageText(
        ctx.chat!.id,
        generatingMessage.message_id,
        '‚ùå Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.'
      );
      return;
    }

    // Generate video
    const videoUrl = await replicateService.generateNSFWVideo(prompt);

    // Update database
    await supabase
      .from('nsfw_generations')
      .update({
        status: 'completed',
        output_url: videoUrl,
        completed_at: new Date().toISOString()
      })
      .eq('id', generation.id);

    // Delete processing message
    await ctx.api.deleteMessage(ctx.chat!.id, generatingMessage.message_id);

    // Send result
    await ctx.replyWithVideo(videoUrl, {
      caption: `‚ú® **NSFW ÎπÑÎîîÏò§ ÏÉùÏÑ± ÏôÑÎ£å!**

üìù ÌîÑÎ°¨ÌîÑÌä∏: "${prompt}"
ü§ñ AI: Zeroscope V2 XL
üí∞ ÎπÑÏö©: 30 ÌÜ†ÌÅ∞

üîû ÏÑ±Ïù∏Ïö© ÏΩòÌÖêÏ∏†ÏûÖÎãàÎã§.`
    });

    console.log('‚úÖ NSFW video generated successfully!');

  } catch (error) {
    console.error('‚ùå NSFW video generation error:', error);
    await ctx.reply(`‚ùå **NSFW ÎπÑÎîîÏò§ ÏÉùÏÑ± Ïã§Ìå®**

Ïò§Î•ò: ${(error as Error).message}

üí° Îã§Î•∏ ÌîÑÎ°¨ÌîÑÌä∏Î°ú Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.`);
  }
});

bot.command('ask', async (ctx) => {
  const question = ctx.message?.text?.replace('/ask', '').trim() || '';
  if (!question) {
    await ctx.reply(`ü§î **AI ÏßàÎ¨∏ÎãµÎ≥Ä ÏÇ¨Ïö©Î≤ï:**\n\n/ask [ÏßàÎ¨∏ÎÇ¥Ïö©]\n\nÏòàÏãú:\n‚Ä¢ /ask ÌååÏù¥Ïç¨ Î¨∏Î≤ï Ïñ¥ÎñªÍ≤å Î∞∞Ïõå?`);
    return;
  }

  console.log(`üîç Explicit question asked: "${question}"`);
  const thinkingMessage = await ctx.reply(`ü§î ÏßàÎ¨∏ÏùÑ Î∂ÑÏÑùÌïòÍ≥† ÏûàÏäµÎãàÎã§...\n\nÏßàÎ¨∏: "${question}"`);

  try {
    const answerResult = await answerQuestion(question, false, ctx.from?.id?.toString(), ctx.chat?.id?.toString());

    // Delete thinking message and send answer
    await ctx.api.deleteMessage(ctx.chat.id, thinkingMessage.message_id);

    await ctx.reply(`ü§ñ **AI ÎãµÎ≥Ä** (/ask Î™ÖÎ†πÏñ¥)

‚ùì **ÏßàÎ¨∏:** ${question}

üí° **ÎãµÎ≥Ä:**
${answerResult.text}

üí∞ **ÎπÑÏö©:** ${formatCost(answerResult.cost)}
‚è±Ô∏è **Ï≤òÎ¶¨ÏãúÍ∞Ñ:** ${answerResult.processingTime}ms
üî§ **ÌÜ†ÌÅ∞:** ${answerResult.tokenUsage.input} ‚Üí ${answerResult.tokenUsage.output}

---
‚ú® Ï∂îÍ∞Ä ÏßàÎ¨∏Ïù¥ ÏûàÏúºÎ©¥ Ïñ∏Ï†úÎì† /ask [ÏßàÎ¨∏] ÌïòÏÑ∏Ïöî!
‚è∞ ${new Date().toLocaleString('ko-KR')}`);


    console.log('‚úÖ Explicit question answered successfully!');
  } catch (error) {
    await handleError(ctx, error as Error, 'ÏßàÎ¨∏ ÎãµÎ≥Ä', thinkingMessage);
  }
});

// Tracking Commands
bot.command('track_start', async (ctx) => {
  console.log('üü¢ /track_start command received');
  const command = parseTrackingCommand('/track_start', ctx);
  if (command) {
    await handleTrackingCommand(command, ctx);
  }
});

bot.command('track_stop', async (ctx) => {
  console.log('üî¥ /track_stop command received');
  const command = parseTrackingCommand('/track_stop', ctx);
  if (command) {
    await handleTrackingCommand(command, ctx);
  }
});

bot.command('summarize', async (ctx) => {
  console.log('üìù /summarize command received');
  const command = parseTrackingCommand('/summarize', ctx);
  if (command) {
    await handleTrackingCommand(command, ctx);
  }
});

bot.command('track_status', async (ctx) => {
  console.log('üìä /track_status command received');
  const command = parseTrackingCommand('/track_status', ctx);
  if (command) {
    await handleTrackingCommand(command, ctx);
  }
});

// Health check and maintenance commands (admin only)
bot.command('health', async (ctx) => {
  console.log('üè• /health command received');
  
  try {
    const { performHealthCheck } = await import('../../src/utils/error-handler');
    const health = await performHealthCheck();
    
    const statusEmoji = {
      database: health.database ? '‚úÖ' : '‚ùå',
      claude_api: health.claude_api ? '‚úÖ' : '‚ùå',
      tracking_system: health.tracking_system ? '‚úÖ' : '‚ùå'
    };
    
    await ctx.reply(`üè• **ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï†êÍ≤Ä Í≤∞Í≥º**

üìä **ÏÑúÎπÑÏä§ ÏÉÅÌÉú:**
‚Ä¢ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§: ${statusEmoji.database}
‚Ä¢ Claude AI: ${statusEmoji.claude_api}  
‚Ä¢ Ï∂îÏ†Å ÏãúÏä§ÌÖú: ${statusEmoji.tracking_system}

${health.issues.length > 0 ? `‚ö†Ô∏è **Î∞úÍ≤¨Îêú Î¨∏Ï†ú:**\n${health.issues.map(issue => `‚Ä¢ ${issue}`).join('\n')}` : '‚úÖ Î™®Îì† ÏãúÏä§ÌÖúÏù¥ Ï†ïÏÉÅ ÏûëÎèô Ï§ëÏûÖÎãàÎã§!'}

‚è∞ Ï†êÍ≤Ä ÏãúÍ∞Ñ: ${new Date().toLocaleString('ko-KR')}`);

  } catch (error) {
    console.error('Health check error:', error);
    await ctx.reply(`‚ùå ÏÉÅÌÉú Ï†êÍ≤Ä Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${(error as Error).message}`);
  }
});

bot.command('maintenance', async (ctx) => {
  console.log('üîß /maintenance command received');
  
  try {
    const { recoverOrphanedSessions, performConsistencyCheck } = await import('../../src/utils/error-handler');
    
    const maintenanceMsg = await ctx.reply('üîß **ÏãúÏä§ÌÖú Ïú†ÏßÄÎ≥¥ÏàòÎ•º ÏãúÏûëÌï©ÎãàÎã§...**\n\n‚è≥ Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨ Î∞è Î≥µÍµ¨ Ï§ë...');
    
    // Perform maintenance tasks
    const [recovery, consistency] = await Promise.all([
      recoverOrphanedSessions(),
      performConsistencyCheck()
    ]);
    
    await ctx.api.editMessageText(
      ctx.chat.id,
      maintenanceMsg.message_id,
      `üîß **ÏãúÏä§ÌÖú Ïú†ÏßÄÎ≥¥Ïàò ÏôÑÎ£å**

üìä **ÏÑ∏ÏÖò Î≥µÍµ¨:**
‚Ä¢ Î≥µÍµ¨Îê®: ${recovery.recovered}Í∞ú
‚Ä¢ ÎßåÎ£åÎê®: ${recovery.expired}Í∞ú

üîç **Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨:**
‚Ä¢ ÏÇ¨Ïö©Ïûê Ï∂îÏ†Å ÏÉÅÌÉú ÏàòÏ†ï: ${consistency.fixed_user_tracking}Í∞ú
‚Ä¢ ÏÑ∏ÏÖò ÌÜµÍ≥Ñ ÏàòÏ†ï: ${consistency.fixed_session_stats}Í∞ú
‚Ä¢ Ï†ïÎ¶¨Îêú Î©îÏãúÏßÄ: ${consistency.cleaned_messages}Í∞ú

‚úÖ Ïú†ÏßÄÎ≥¥ÏàòÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!

‚è∞ ÏôÑÎ£å ÏãúÍ∞Ñ: ${new Date().toLocaleString('ko-KR')}`
    );

  } catch (error) {
    console.error('Maintenance error:', error);
    await ctx.reply(`‚ùå Ïú†ÏßÄÎ≥¥Ïàò Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${(error as Error).message}`);
  }
});

// Photo handling moved to image-edit-handler.ts for automatic AI suggestions
// Old photo handler has been completely removed to avoid conflicts
// Now all photo handling is done in image-edit-handler.ts which provides:
// - Automatic AI analysis and edit suggestions when photos are uploaded
// - Single photo: prioritizes figurine, styling, quality enhancement
// - Multiple photos: prioritizes merging, outfit swap, background replacement

// Handle ALL text messages - unified handler
bot.on('message:text', async (ctx) => {
  const text = ctx.message.text;
  const replyToMessage = ctx.message.reply_to_message;
  
  console.log(`üí¨ DEBUGGING - Message received: "${text}"`);
  console.log(`üí¨ DEBUGGING - From user: ${ctx.from?.first_name} (ID: ${ctx.from?.id})`);
  console.log(`üí¨ DEBUGGING - Is bot: ${ctx.from?.is_bot}`);
  console.log(`üí¨ DEBUGGING - Bot ID: ${ctx.me?.id}`);

  // üö® CRITICAL: Skip if message is from the bot itself to prevent infinite loops
  if (ctx.from?.is_bot || ctx.from?.id === ctx.me?.id) {
    console.log(`ü§ñ Skipping bot's own message: ${text}`);
    return;
  }

  // üö® CRITICAL: Skip if this is a command - let command handlers process them
  if (text.startsWith('/')) {
    console.log(`‚ö° Skipping command "${text}" - letting command handlers process it`);
    return;
  }

  // [REMOVED] Duplicate image editing handler - using the improved one below
  
  // Check if this is a reply to a photo with editing request
  if (replyToMessage && 'photo' in replyToMessage && replyToMessage.photo) {
    console.log('üñºÔ∏è Reply to photo detected, checking for editing request...');
    console.log('üìù Reply text:', text);
    console.log('üì∑ Photo count:', replyToMessage.photo.length);

    // Check for Dobby-style editing request or direct editing keywords
    const isDobbyEdit = text.includes('ÎèÑÎπÑÏïº');
    const editingKeywords = /(Ìé∏Ïßë|ÏàòÏ†ï|Î≥¥Ï†ï|Î∞îÍøî|Î≥ÄÍ≤Ω|Ï°∞Ï†ï|Í∞úÏÑ†|ÎßåÎì§Ïñ¥|Ï∂îÍ∞Ä|Î∞∞Í≤Ω|ÏòàÏÅòÍ≤å|Î©ãÏßÄÍ≤å|enhance|edit|modify|adjust|add|create|change|background)/i;

    if (isDobbyEdit || editingKeywords.test(text)) {
      console.log('‚úèÔ∏è Image editing request detected!');
      console.log('üîç Is Dobby edit:', isDobbyEdit);
      console.log('üìù Edit request:', text);
      
      try {
        // Get the largest photo
        console.log('üì∑ Getting largest photo from message...');
        const photo = replyToMessage.photo[replyToMessage.photo.length - 1];
        console.log('üì∑ Photo file_id:', photo.file_id);

        console.log('üîÑ Getting file info from Telegram API...');
        const file = await ctx.api.getFile(photo.file_id);
        console.log('üìÅ File path:', file.file_path);

        // Declare variables at the start of the try block
        let uploadedFileUri: string | null = null;
        let useFilesAPI = false;

        if (!file.file_path) {
          console.error('‚ùå No file path received from Telegram');
          await ctx.reply('‚ùå Ïù¥ÎØ∏ÏßÄ ÌååÏùºÏùÑ Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.');
          return;
        }

        // Extract editing intent from text (remove "ÎèÑÎπÑÏïº" if present)
        const editRequest = text.replace(/ÎèÑÎπÑÏïº[,\s]*/i, '').trim();

        // Send processing message with Dobby personality if requested
        const processingMsg = isDobbyEdit
          ? await ctx.reply(`üßô‚Äç‚ôÄÔ∏è **ÎèÑÎπÑÍ∞Ä Ïù¥ÎØ∏ÏßÄÎ•º Ìé∏ÏßëÌïòÍ≥† ÏûàÏäµÎãàÎã§!**

üì∏ **ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù Ï§ë**: ÎèÑÎπÑÍ∞Ä ÎßàÎ≤ïÏúºÎ°ú Î∂ÑÏÑùÌï©ÎãàÎã§...
‚úèÔ∏è **Ìé∏Ïßë ÏöîÏ≤≠**: "${editRequest}"
ü™Ñ **ÎèÑÎπÑÏùò ÎßàÎ≤ï**: Gemini Vision + Imagen AI

‚ö° ÎèÑÎπÑÍ∞Ä Ïó¥Ïã¨Ìûà ÏûëÏóÖ Ï§ëÏûÖÎãàÎã§...`)
          : await ctx.reply(`üé® **Ïù¥ÎØ∏ÏßÄ Ìé∏Ïßë Ï§ë...**

üì∏ **ÏõêÎ≥∏ Ïù¥ÎØ∏ÏßÄ Î∂ÑÏÑù**: ÏßÑÌñâ Ï§ë
‚úèÔ∏è **Ìé∏Ïßë ÏöîÏ≤≠**: "${editRequest}"
ü§ñ **AI Ï≤òÎ¶¨**: Gemini Vision + Imagen

‚ö° Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî...`);

        // Download image
        console.log('üì• Downloading image from Telegram...');
        const imageUrl = `https://api.telegram.org/file/bot${BOT_TOKEN}/${file.file_path}`;
        const imageResponse = await fetchWithTimeout(imageUrl, {}, 10000); // 10s timeout for download
        const imageArrayBuffer = await imageResponse.arrayBuffer();
        const imageBuffer = Buffer.from(imageArrayBuffer);
        const imageBase64 = imageBuffer.toString('base64');

        console.log('‚úÖ Image downloaded, size:', imageBuffer.length, 'bytes');

        // Determine if we should use Files API based on size (15MB limit for inline data)
        useFilesAPI = imageBuffer.length > FILES_API_THRESHOLD;

        console.log(`üìä Image size analysis:`, {
          sizeBytes: imageBuffer.length,
          sizeMB: (imageBuffer.length / (1024 * 1024)).toFixed(2),
          threshold: (FILES_API_THRESHOLD / (1024 * 1024)).toFixed(0) + 'MB',
          useFilesAPI: useFilesAPI,
          method: useFilesAPI ? 'Files API (Large Image)' : 'Inline Data (Standard)'
        });

        // Use Gemini for real image editing
        console.log('üé® Starting real image editing with Gemini...');

        const editStartTime = Date.now();
        // uploadedFileUri already declared above

        // Try multiple Gemini models for image editing
        let editResponse;
        let modelUsed = '';

        // Try Gemini 2.5 Flash Image Preview for actual image editing
        try {
          console.log('üîÑ Trying Gemini 2.5 Flash Image Preview for direct image editing...');

          // Upload file if using Files API
          if (useFilesAPI && !uploadedFileUri) {
            console.log('üì§ Uploading large image to Files API...');
            const uploadResult = await uploadToGeminiFiles(imageBuffer, 'image/jpeg');
            uploadedFileUri = uploadResult.uri;
            console.log('‚úÖ Image uploaded to Files API:', uploadedFileUri);
          }

          // Use Files API or inline data based on image size
          if (useFilesAPI && uploadedFileUri) {
            editResponse = await processImageWithFilesAPI(
              uploadedFileUri,
              editRequest,
              'gemini-2.5-flash-image-preview'
            );
          } else {
            editResponse = await fetchWithTimeout(
              `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${GOOGLE_API_KEY}`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  contents: [{
                    parts: [
                      {
                        text: `Generate an edited version of this image with the following modification: ${editRequest}

                        Important: You must return the edited image itself, not a text description.
                        Apply the requested changes directly to the image while preserving the original subjects and composition.
                        Output: Modified image with the requested changes applied.`
                      },
                      {
                        inline_data: {
                          mime_type: 'image/jpeg',
                          data: imageBase64
                        }
                      }
                    ]
                  }],
                  generationConfig: {
                    temperature: 0.4,
                    maxOutputTokens: 8192
                  }
                })
              },
              30000 // 30-second timeout
            );
          }
          modelUsed = 'Gemini 2.5 Flash Image Preview' + (useFilesAPI ? ' (Files API)' : '');

          // Trust that Gemini will return an image with the improved prompt
        } catch (error) {
          console.log('‚ö†Ô∏è Gemini 2.5 Flash Image Preview failed or returned text:', error);

          // Try Gemini 2.0 Flash Experimental as second attempt
          try {
            console.log('üîÑ Trying Gemini 2.0 Flash Experimental as fallback...');

            // Upload file if using Files API and not already uploaded
            if (useFilesAPI && !uploadedFileUri) {
              console.log('üì§ Uploading large image to Files API for fallback...');
              const uploadResult = await uploadToGeminiFiles(imageBuffer, 'image/jpeg');
              uploadedFileUri = uploadResult.uri;
              console.log('‚úÖ Image uploaded to Files API:', uploadedFileUri);
            }

            // Use Files API or inline data based on image size
            if (useFilesAPI && uploadedFileUri) {
              editResponse = await processImageWithFilesAPI(
                uploadedFileUri,
                editRequest,
                'gemini-2.0-flash-exp'
              );
            } else {
              editResponse = await fetchWithTimeout(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${GOOGLE_API_KEY}`,
                {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    contents: [{
                      parts: [
                        {
                          text: `You are an image editor. Edit this image based on: "${editRequest}"

                          Modify the image to fulfill this request while maintaining the original subjects and composition.
                          Apply the specific changes requested.`
                        },
                        {
                          inline_data: {
                            mime_type: 'image/jpeg',
                            data: imageBase64
                          }
                        }
                      ]
                    }],
                    generationConfig: {
                      temperature: 0.4,
                      maxOutputTokens: 8192
                    }
                  })
                },
                25000 // 25-second timeout
              );
            }
            modelUsed = 'Gemini 2.0 Flash Experimental' + (useFilesAPI ? ' (Files API)' : '');
          } catch (exp2Error) {
            console.log('‚ö†Ô∏è Gemini 2.0 Flash Experimental also failed or returned text:', exp2Error);

          // Final Fallback: Use Gemini for analysis then Imagen for generation
          console.log('üîÑ Final Fallback: Gemini analysis + Imagen generation');

          // First, analyze the image with Gemini
          // Upload file if using Files API and not already uploaded
          if (useFilesAPI && !uploadedFileUri) {
            console.log('üì§ Uploading large image to Files API for analysis...');
            const uploadResult = await uploadToGeminiFiles(imageBuffer, 'image/jpeg');
            uploadedFileUri = uploadResult.uri;
            console.log('‚úÖ Image uploaded to Files API:', uploadedFileUri);
          }

          let analysisResponse;
          if (useFilesAPI && uploadedFileUri) {
            // Use Files API for analysis
            analysisResponse = await fetchWithTimeout(
              `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GOOGLE_API_KEY}`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  contents: [{
                    parts: [
                      {
                        text: `Analyze this image and create a detailed prompt for: "${editRequest}".
                        Describe what's in the image and how to modify it according to the request.
                        Output ONLY a concise prompt for image generation.`
                      },
                      {
                        fileData: {
                          mimeType: "image/jpeg",
                          fileUri: uploadedFileUri
                        }
                      }
                    ]
                  }],
                  generationConfig: {
                    temperature: 0.3,
                    maxOutputTokens: 150
                  }
                })
              },
              10000 // 10s timeout
            );
          } else {
            // Use inline data for smaller images
            analysisResponse = await fetchWithTimeout(
              `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GOOGLE_API_KEY}`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  contents: [{
                    parts: [
                      {
                        text: `Analyze this image and create a detailed prompt for: "${editRequest}".
                        Describe what's in the image and how to modify it according to the request.
                        Output ONLY a concise prompt for image generation.`
                      },
                      { inline_data: { mime_type: 'image/jpeg', data: imageBase64 } }
                    ]
                  }],
                  generationConfig: {
                    temperature: 0.3,
                    maxOutputTokens: 150
                  }
                })
              },
              10000 // 10s timeout
            );
          }

          if (!analysisResponse.ok) {
            throw new Error('Gemini analysis failed');
          }

          const analysisData = await analysisResponse.json();
          const editPrompt = (analysisData as any).candidates?.[0]?.content?.parts?.[0]?.text?.trim() || editRequest;

          console.log('üìù Generated edit prompt:', editPrompt);

          // Generate with Imagen 4.0 based on analysis
          editResponse = await fetchWithTimeout(
            'https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict',
            {
              method: 'POST',
              headers: {
                'x-goog-api-key': GOOGLE_API_KEY,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                instances: [{
                  prompt: editPrompt + ' High quality, photorealistic, detailed.'
                }],
                parameters: {
                  sampleCount: 1,
                  sampleImageSize: '1K',
                  aspectRatio: '1:1'
                }
              })
            },
            20000 // 20s timeout
          );
          modelUsed = useFilesAPI
            ? 'Gemini Analysis (Files API) + Imagen 4.0'
            : 'Gemini Analysis (Inline) + Imagen 4.0';
          }
        } finally {
          // Clean up uploaded file if it was used
          if (uploadedFileUri) {
            // Don't await - let cleanup happen in background
            deleteGeminiFile(uploadedFileUri).catch(error => {
              console.warn('Background file cleanup failed:', error);
            });
          }
        }

        if (!editResponse.ok) {
          const errorText = await editResponse.text();
          throw new Error(`API error: ${editResponse.status} - ${errorText}`);
        }

        const editData = await editResponse.json();
        const editProcessingTime = Date.now() - editStartTime;

        console.log('üìä Response structure:', {
          model: modelUsed,
          hasCandidates: !!(editData as any).candidates,
          candidatesCount: (editData as any).candidates?.length,
          hasPredictions: !!(editData as any).predictions,
          fullResponse: JSON.stringify(editData).substring(0, 500) // Log first 500 chars for debugging
        });

        // Check for IMAGE_SAFETY rejection
        const finishReason = (editData as any).candidates?.[0]?.finishReason;
        if (finishReason === 'IMAGE_SAFETY') {
          console.log('‚ö†Ô∏è Image editing blocked by safety filter');
          throw new Error('IMAGE_SAFETY: Content blocked by safety filters');
        }

        // Extract image data based on model
        let editedImageData;
        if (modelUsed.includes('Imagen')) {
          editedImageData = (editData as any).predictions?.[0]?.bytesBase64Encoded;
          console.log('üì∏ Imagen response - Image data found:', !!editedImageData);
        } else {
          // Gemini model response - check if it returned an image or text
          const candidates = (editData as any).candidates;
          const parts = candidates?.[0]?.content?.parts;

          console.log('üìä Gemini response analysis:', {
            hasContent: !!candidates?.[0]?.content,
            partsCount: parts?.length,
            partsTypes: parts?.map((p: any) =>
              p.inline_data ? 'image' : p.inlineData ? 'image' : p.text ? 'text' : 'unknown'
            ),
            firstPartKeys: parts?.[0] ? Object.keys(parts[0]) : null
          });

          if (parts) {
            // Look for image data in the response (check all possible formats)
            const imagePart = parts.find((part: any) =>
              part.inline_data?.mime_type?.startsWith('image/') ||
              part.inlineData?.mimeType?.startsWith('image/') ||
              part.inline_data?.mimeType?.startsWith('image/') ||
              part.inlineData?.mime_type?.startsWith('image/')
            );

            if (imagePart) {
              // Handle multiple possible response formats
              editedImageData = imagePart.inline_data?.data ||
                               imagePart.inlineData?.data ||
                               imagePart.inline_data?.data ||
                               imagePart.inlineData?.data;
              console.log('‚úÖ Gemini returned edited image! Data length:', editedImageData?.length);
            } else if (parts[0]?.text) {
              // If Gemini returned only text, it didn't edit the image
              console.log('‚ö†Ô∏è Gemini returned text instead of image, using Imagen fallback');
              console.log('üìù Gemini text response:', parts[0].text.substring(0, 200));
              const prompt = parts[0].text.substring(0, 500) || editRequest;

              // Generate with Imagen
              const imagenResponse = await fetchWithTimeout(
                'https://generativelanguage.googleapis.com/v1beta/models/imagen-4.0-generate-001:predict',
                {
                  method: 'POST',
                  headers: {
                    'x-goog-api-key': GOOGLE_API_KEY,
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    instances: [{ prompt }],
                    parameters: {
                      sampleCount: 1,
                      sampleImageSize: '1K',
                      aspectRatio: '1:1'
                    }
                  })
                },
                15000 // 15s timeout for final fallback
              );

              if (imagenResponse.ok) {
                const imagenData = await imagenResponse.json();
                editedImageData = (imagenData as any).predictions?.[0]?.bytesBase64Encoded;
                modelUsed = 'Gemini + Imagen 4.0 (Fallback)';
              }
            }
          }
        }

        if (!editedImageData) {
          throw new Error('No edited image received from API');
        }

        console.log(`‚úÖ Image editing completed in ${editProcessingTime}ms using ${modelUsed}`);

        // Create buffer from the edited image
        const editedImageBuffer = Buffer.from(editedImageData, 'base64');

        // Delete processing message
        await ctx.api.deleteMessage(ctx.chat.id, processingMsg.message_id);

        // Calculate cost based on method used
        const baseCost = 0.002; // Base processing cost
        const filesCost = useFilesAPI ? calculateGeminiFilesCost() : 0; // Additional Files API cost
        const estimatedCost = baseCost + filesCost;

        // Send edited image with enhanced information
        const caption = isDobbyEdit
          ? `üßô‚Äç‚ôÄÔ∏è **ÎèÑÎπÑÍ∞Ä ÎßàÎ≤ïÏúºÎ°ú Ìé∏ÏßëÏùÑ ÏôÑÎ£åÌñàÏäµÎãàÎã§!**

‚úèÔ∏è **Ï£ºÏù∏ÎãòÏùò ÏöîÏ≤≠**: "${editRequest}"
ü™Ñ **ÎèÑÎπÑÏùò ÎßàÎ≤ï ÎèÑÍµ¨**: ${modelUsed}
üìä **Ï≤òÎ¶¨ Î∞©Ïãù**: ${useFilesAPI ? 'Files API (ÎåÄÏö©Îüâ)' : 'Inline Data (ÌëúÏ§Ä)'}

üí∞ **ÎπÑÏö©**: ${formatCost(estimatedCost)}
‚è±Ô∏è **Ï≤òÎ¶¨ÏãúÍ∞Ñ**: ${editProcessingTime}ms

‚ú® **ÎèÑÎπÑÏùò Ìé∏Ïßë Í≤∞Í≥ºÏûÖÎãàÎã§!**

ÎèÑÎπÑÎäî Ï£ºÏù∏ÎãòÏù¥ ÎßåÏ°±ÌïòÏãúÍ∏∏ Î∞îÎûçÎãàÎã§! üßô‚Äç‚ôÄÔ∏è`
          : `üé® **Ïù¥ÎØ∏ÏßÄ Ìé∏Ïßë ÏôÑÎ£å!**

‚úèÔ∏è **Ìé∏Ïßë ÏöîÏ≤≠**: "${editRequest}"
ü§ñ **AI Ìé∏Ïßë**: ${modelUsed}
üìä **Ï≤òÎ¶¨ Î∞©Ïãù**: ${useFilesAPI ? 'Files API (ÎåÄÏö©Îüâ)' : 'Inline Data (ÌëúÏ§Ä)'}

üí∞ **ÎπÑÏö©**: ${formatCost(estimatedCost)}
‚è±Ô∏è **Ï≤òÎ¶¨ÏãúÍ∞Ñ**: ${editProcessingTime}ms

‚ú® **Ìé∏ÏßëÎêú Ïù¥ÎØ∏ÏßÄÏûÖÎãàÎã§!**`;

        await ctx.replyWithPhoto(new InputFile(editedImageBuffer), {
          caption: caption
        });

        console.log('‚úÖ Image editing completed and sent to user');
        
      } catch (error) {
        console.error('‚ùå Image editing error:', error);

        // Check if it's a safety error
        const errorMessage = error instanceof Error ? error.message : 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò';
        const isSafetyError = errorMessage.includes('IMAGE_SAFETY');

        if (isSafetyError) {
          await ctx.reply(`‚ö†Ô∏è **ÏïàÏ†Ñ ÌïÑÌÑ∞Ïóê ÏùòÌï¥ Ï∞®Îã®Îê®**

ÏöîÏ≤≠ÌïòÏã† Ìé∏Ïßë ÎÇ¥Ïö©Ïù¥ Google AIÏùò ÏïàÏ†Ñ Ï†ïÏ±ÖÏóê ÏúÑÎ∞òÎê©ÎãàÎã§.

üí° **Îã§Î•∏ Î∞©Î≤ïÏúºÎ°ú ÏãúÎèÑÌï¥Î≥¥ÏÑ∏Ïöî:**
- Îçî ÏàúÌôîÎêú ÌëúÌòÑÏúºÎ°ú ÏöîÏ≤≠Ìï¥Ï£ºÏÑ∏Ïöî
- Ïòà: "ÏùòÏÉÅÏùÑ Ï∫êÏ£ºÏñºÌïú Ïò∑ÏúºÎ°ú Î≥ÄÍ≤Ω"
- Ïòà: "Ïò∑ ÏÉâÏÉÅÏùÑ ÌååÎûÄÏÉâÏúºÎ°ú Î≥ÄÍ≤Ω"

üîí Ï∞®Îã®Îêú ÎÇ¥Ïö©: ÎÖ∏Ï∂úÏù¥ ÎßéÏùÄ ÏùòÏÉÅ, ÏÑ±Ï†Å ÏΩòÌÖêÏ∏† Îì±`);
        } else {
          await ctx.reply(`‚ùå **Ïù¥ÎØ∏ÏßÄ Ìé∏Ïßë Ïã§Ìå®**

Ïò§Î•ò: ${errorMessage}

üí° **Îã§Ïãú ÏãúÎèÑÌï¥Î≥¥ÏÑ∏Ïöî:**
- Ïù¥ÎØ∏ÏßÄÏóê replyÎ°ú "Ìé∏ÏßëÌï¥Ï§ò", "Î≥¥Ï†ïÌï¥Ï§ò", "Í∞úÏÑ†Ìï¥Ï§ò" Îì±ÏúºÎ°ú ÏöîÏ≤≠
- Íµ¨Ï≤¥Ï†ÅÏù∏ Ìé∏Ïßë ÎÇ¥Ïö©ÏùÑ Î™ÖÏãúÌïòÎ©¥ Îçî Ï¢ãÏäµÎãàÎã§
- ÎåÄÏö©Îüâ Ïù¥ÎØ∏ÏßÄÎäî Files APIÎ°ú ÏûêÎèô Ï≤òÎ¶¨Îê©ÎãàÎã§`);
        }
      }
      
      return; // Exit after handling image editing
    } else {
      console.log('üí¨ Reply to photo but no editing keywords detected');
    }
  }

  // Check for Dobby activation and other commands
  console.log(`üîç DEBUGGING - Checking Dobby activation for: "${text}"`);
  const dobbyCheck = isDobbyActivated(text);
  console.log(`üîç DEBUGGING - Dobby check result:`, dobbyCheck);
  
  // Check for tracking commands (Dobby-style commands)
  const trackingCommand = parseTrackingCommand(text, ctx);
  console.log(`üîç DEBUGGING - Tracking command result:`, trackingCommand);
  
  // Handle tracking commands if detected
  if (trackingCommand) {
    console.log(`üéØ Tracking command detected: ${trackingCommand.type}`);
    await handleTrackingCommand(trackingCommand, ctx);
    return;
  }

  if (dobbyCheck.activated) {
    console.log(`üßô‚Äç‚ôÄÔ∏è DEBUGGING - Dobby activated! Command: ${dobbyCheck.command}, Content: "${dobbyCheck.content}"`);

    if (dobbyCheck.command === 'image') {
      // Handle Dobby image generation
      if (!dobbyCheck.content) {
        await ctx.reply(`üßô‚Äç‚ôÄÔ∏è **ÎèÑÎπÑÍ∞Ä Ï§ÄÎπÑÎêòÏóàÏäµÎãàÎã§!**

üé® **Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± ÏÇ¨Ïö©Î≤ï:**
‚Ä¢ "ÎèÑÎπÑÏïº, Í∑ÄÏó¨Ïö¥ Í∞ïÏïÑÏßÄ Í∑∏Î†§Ï§ò"
‚Ä¢ "ÎèÑÎπÑÏïº, ÎØ∏ÎûòÏ†ÅÏù∏ Î°úÎ¥á Í∑∏Î†§Ï§ò"
‚Ä¢ "ÎèÑÎπÑÏïº, ÏïÑÎ¶ÑÎã§Ïö¥ ÌíçÍ≤Ω Í∑∏Î¶º Í∑∏Î†§Ï§ò"

‚ú® Ïñ¥Îñ§ Í∑∏Î¶ºÏùÑ Í∑∏Î†§ÎìúÎ¶¥ÍπåÏöî?`);
        return;
      }

      console.log(`üé® Dobby image generation: "${dobbyCheck.content}"`);

      // Send immediate response to prevent timeout
      const processingMsg = `üßô‚Äç‚ôÄÔ∏è **ÎèÑÎπÑÍ∞Ä Í∑∏Î¶ºÏùÑ Í∑∏Î¶¨Í≥† ÏûàÏäµÎãàÎã§!**

üé® Ï£ºÏù∏ÎãòÏùò ÏöîÏ≤≠: "${dobbyCheck.content}"
‚ú® ÎèÑÎπÑÍ∞Ä ÎßàÎ≤ïÏúºÎ°ú Í∑∏Î¶ºÏùÑ ÎßåÎì§Í≥† ÏûàÏñ¥Ïöî...

‚ö° Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî!`;

      const generatingMessage = await ctx.reply(processingMsg);

      try {
        const imageResult = await generateImageWithImagen(dobbyCheck.content, true, ctx.from?.id?.toString(), ctx.chat?.id?.toString());

        // Create buffer from base64
        const imageBuffer = Buffer.from(imageResult.imageData.replace(/^data:image\/[a-z]+;base64,/, ''), 'base64');

        // Get dynamic success message with cost information
        const successMsg = await getSystemMessage('dobby_success_image', {
          user_input: dobbyCheck.content,
          cost: formatCost(imageResult.cost),
          processing_time: imageResult.processingTime,
          timestamp: new Date().toLocaleString('ko-KR')
        });

        // Send image directly from buffer
        await ctx.replyWithPhoto(new InputFile(imageBuffer, `dobby_${Date.now()}.png`), {
          caption: `${successMsg}

üí∞ **ÎπÑÏö©**: ${formatCost(imageResult.cost)}
‚è±Ô∏è **Ï≤òÎ¶¨ÏãúÍ∞Ñ**: ${imageResult.processingTime}ms
üé® **ÎèÑÍµ¨**: Google Imagen 4.0`
        });

        // Delete generating message
        await ctx.api.deleteMessage(ctx.chat.id, generatingMessage.message_id);

        console.log('‚úÖ Dobby image generation successful!');

      } catch (error) {
        console.error('Dobby image generation error:', error);

        await ctx.api.editMessageText(
          ctx.chat.id,
          generatingMessage.message_id,
          `üßô‚Äç‚ôÄÔ∏è **ÎèÑÎπÑÍ∞Ä Ïã§ÏàòÌñàÏäµÎãàÎã§...**

‚ùå Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ± Ï§ë Ïò§Î•ò: ${(error as Error).message}

üòî ÎèÑÎπÑÎäî Ïã§Ìå®Î•º Ïö©ÏÑúÎ∞õÏßÄ Î™ªÌï©ÎãàÎã§...
üí° Ïû†Ïãú ÌõÑ Îã§Ïãú ÎßêÏîÄÌï¥Ï£ºÏãúÎ©¥ Îçî Ïó¥Ïã¨Ìûà ÌïòÍ≤†ÏäµÎãàÎã§!`
        );
      }

    } else if (dobbyCheck.command === 'help') {
      // Handle Dobby help command
      console.log(`‚ùì Dobby help request: "${dobbyCheck.content}"`);

      try {
        const helpMessage = await getHelpMessage();
        await ctx.reply(`üßô‚Äç‚ôÄÔ∏è **ÎèÑÎπÑÍ∞Ä ÏÇ¨Ïö©Î≤ïÏùÑ ÏïåÎ†§ÎìúÎ¶ΩÎãàÎã§!**

${helpMessage}

üè† Ï£ºÏù∏ÎãòÏùÑ ÏúÑÌï¥ Ïñ∏Ï†úÎì†ÏßÄ ÎèÑÏõÄÏùÑ ÎìúÎ¶¥ Ï§ÄÎπÑÍ∞Ä ÎêòÏñ¥ÏûàÏäµÎãàÎã§!`);

        console.log('‚úÖ Dobby help message sent successfully!');

      } catch (error) {
        console.error('Dobby help error:', error);
        await ctx.reply(`üßô‚Äç‚ôÄÔ∏è **ÎèÑÎπÑÍ∞Ä Ïã§ÏàòÌñàÏäµÎãàÎã§...**

‚ùå ÎèÑÏõÄÎßêÏùÑ Í∞ÄÏ†∏Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.

üí° /help Î™ÖÎ†πÏñ¥Î•º ÏÇ¨Ïö©ÌïòÏãúÍ±∞ÎÇò Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî!`);
      }

    } else if (dobbyCheck.command === 'ask') {
      // Handle Dobby Q&A
      console.log(`ü§î Dobby Q&A: "${dobbyCheck.content}"`);

      // Get dynamic processing message
      const processingMsg = await getSystemMessage('dobby_processing_qa', {
        question: dobbyCheck.content
      });
      
      const thinkingMessage = await ctx.reply(processingMsg);

      try {
        const answerResult = await answerQuestion(dobbyCheck.content, true, ctx.from?.id?.toString(), ctx.chat?.id?.toString());

        // Delete thinking message and send answer
        await ctx.api.deleteMessage(ctx.chat.id, thinkingMessage.message_id);

        // Get dynamic success message
        const successMsg = await getSystemMessage('dobby_success_qa', {
          question: dobbyCheck.content,
          answer: answerResult.text,
          cost: formatCost(answerResult.cost),
          processing_time: answerResult.processingTime,
          timestamp: new Date().toLocaleString('ko-KR')
        });

        await ctx.reply(`${successMsg}

üí∞ **ÎπÑÏö©**: ${formatCost(answerResult.cost)}
‚è±Ô∏è **Ï≤òÎ¶¨ÏãúÍ∞Ñ**: ${answerResult.processingTime}ms
üî§ **ÌÜ†ÌÅ∞**: ${answerResult.tokenUsage.input} ‚Üí ${answerResult.tokenUsage.output}
üß† **AI**: Claude 3.5 Sonnet`);

        console.log('‚úÖ Dobby Q&A successful!');

      } catch (error) {
        console.error('Dobby Q&A error:', error);

        await ctx.api.editMessageText(
          ctx.chat.id,
          thinkingMessage.message_id,
          `üßô‚Äç‚ôÄÔ∏è **ÎèÑÎπÑÍ∞Ä Ïã§ÏàòÌñàÏäµÎãàÎã§...**

‚ùå ÎãµÎ≥Ä Ï§ë Ïò§Î•ò: ${(error as Error).message}

üòî ÎèÑÎπÑÎäî ÏïÑÏßÅ Î™®Î•¥Îäî Í≤ÉÏù¥ ÎßéÏäµÎãàÎã§...
üí° Îã§Î•∏ Î∞©ÏãùÏúºÎ°ú Î¨ºÏñ¥Î¥êÏ£ºÏãúÎ©¥ Îçî Ïó¥Ïã¨Ìûà ÌïòÍ≤†ÏäµÎãàÎã§!`
        );
      }
    }

    return; // Dobby handled the message, skip other processing
  }

  // Do not respond to regular messages without "ÎèÑÎπÑÏïº" keyword
  // Only slash commands and messages with "ÎèÑÎπÑÏïº" should trigger responses
  console.log(`üí≠ Regular message (not Dobby command): "${text}" - no response`);
});

// Register image editing handlers
registerImageEditHandlers(bot);

// Debug middleware - log ALL messages
bot.use(async (ctx, next) => {
  console.log('üîç DEBUG - Message type:', ctx.message?.text ? 'text' : ctx.message?.photo ? 'photo' : 'other');
  console.log('üîç DEBUG - Message content:', ctx.message?.text || '[non-text]');
  console.log('üîç DEBUG - From:', ctx.from?.first_name, '(', ctx.from?.id, ')');
  await next();

});

// Error handling
bot.catch((err) => {
  console.error('Production bot error:', err);
});

// Create webhook callback
const webhookHandler = webhookCallback(bot, 'std/http');

// Netlify Functions handler
export const handler: Handler = async (event: HandlerEvent, _context: HandlerContext) => {
  console.log('üåê WEBHOOK ENTRY POINT - Received request');
  console.log('üåê Method:', event.httpMethod);
  console.log('üåê Body:', event.body);
  console.log('üåê Headers:', JSON.stringify(event.headers, null, 2));

  try {
    if (event.httpMethod !== 'POST') {
      return { statusCode: 405, body: JSON.stringify({ error: 'Method not allowed' }) };
    }

    const request = new Request('https://example.com/webhook', {
      method: 'POST',
      headers: { 'content-type': 'application/json', ...event.headers },
      body: event.body
    });

    // Process webhook normally - no timeout on Render
    const response = await webhookHandler(request);

    console.log('‚úÖ Webhook processed');

    return {
      statusCode: response.status,
      headers: { 'Content-Type': 'application/json' },
      body: await response.text()
    };
  } catch (error) {
    console.error('‚ùå Webhook processing error:', error);
    return {
      statusCode: 200, // Return 200 to prevent Telegram retry
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ok: true })
    };
  }
};
